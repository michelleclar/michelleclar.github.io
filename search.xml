<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SpringBoot</title>
      <link href="/2023/01/27/SpringBoot%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/SpringBoot%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="说说Spring-Boot常用的注解"><a href="#说说Spring-Boot常用的注解" class="headerlink" title="说说Spring Boot常用的注解"></a>说说Spring Boot常用的注解</h3><p>解题思路</p><p>得分点 Spring Boot常用注解的作用 </p><p><strong>标准回答</strong> </p><p>关于Spring Boot常用注解： </p><p>@SpringBootApplication注解： 在Spring Boot入口类中,唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解,用于开启自动配置,准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。 </p><p>@EnableAutoConfiguration注解： @EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置,它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中,被自动配置的组件来自项目自身和项目依赖的jar包中。 </p><p>@Import注解： @EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分,也是自动配置功能的核心实现者。 </p><p>@Conditional注解： @Conditional注解是由Spring 4.0版本引入的新特性,可根据是否满足指定的条件来决定是否进行Bean的实例化及装配,比如,设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之,就是根据一些特定条件来控制Bean实例化的行为。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2023/01/27/Spring%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/Spring%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="说说你对AOP的理解"><a href="#说说你对AOP的理解" class="headerlink" title="说说你对AOP的理解"></a>说说你对AOP的理解</h3><p>解题思路</p><p>得分点 AOP概念、AOP作用、AOP的实现方式 标准回答 AOP是一种编程思想,是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。</p><p>面向对象编程将程序抽象成各个层次的对象,而面向切面编程是将程序抽象成各个切面。所谓切面,相当于应用对象间的横切点,我们可以将其单独抽象为单独的模块。 </p><p>AOP技术利用一种称为“横切”的技术,剖解开封装对象的内部,将影响多个类的公共行为封装到一个可重用的模块中,并将其命名为切面。</p><p>所谓的切面,简单来说就是与业务无关,却为业务模块所共同调用的逻辑,将其封装起来便于减少系统的重复代码,降低模块的耦合度,有利用未来的可操作性和可维护性。 </p><p>利用AOP可以对业务逻辑各个部分进行隔离,从而使业务逻辑各部分之间的耦合度降低,提高程序的可重用性,同时提高开发效率。 </p><p>AOP可以有多种实现方式,而Spring AOP支持如下两种实现方式。 </p><ul><li>-JDK动态代理：这是Java提供的动态代理技术,可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式,在接口的代理实例中织入代码。 </li><li>-<strong>CGLib</strong>动态代理：采用底层的字节码技术,在运行时创建子类代理的实例。当目标对象不存在接口时,Spring AOP就会采用这种方式,在子类实例中织入代码。</li></ul><p> 加分回答 在应用场景方面,Spring AOP为IOC的使用提供了更多的便利,一方面,应用可以直接使用AOP的功能,设计应用的横切关注点,把跨越应用程序多个模块的功能抽象出来,并通过简单的AOP的使用,灵活地编制到模块中,比如可以通过AOP实现应用程序中的日志功能。另一方面,在Spring内部,例如事务处理之类的一些支持模块也是通过Spring AOP来实现的。 AOP不能增强的类：</p><ol><li>Spring AOP只能对IoC容器中的Bean进行增强,对于不受容器管理的对象不能增强。 </li><li>由于CGLib采用动态创建子类的方式生成代理对象,所以不能对final修饰的类进行代理。</li></ol><h3 id="说说你对IoC的理解"><a href="#说说你对IoC的理解" class="headerlink" title="说说你对IoC的理解"></a>说说你对IoC的理解</h3><p>解题思路</p><p>得分点 控制反转与依赖注入含义 标准回答 IoC是控制反转的意思,是一种面向对象编程的设计思想。</p><p>在不采用这种思想的情况下,我们需要自己维护对象与对象之间的依赖关系,很容易造成对象之间的耦合度过高,在一个大型的项目中这十分的不利于代码的维护。</p><p>IoC则可以解决这种问题,它可以帮我们维护对象与对象之间的依赖关系,并且降低对象之间的耦合度。 </p><p>说到IoC就不得不说DI,DI是依赖注入的意思,它是IoC实现的实现方式。</p><p>由于IoC这个词汇比较抽象而DI比较直观,所以很多时候我们就用DI来代替它,在很多时候我们简单地将IoC和DI划等号,这是一种习惯。</p><p>实现依赖注入的关键是IoC容器,它的本质就是一个工厂。</p><p> <strong>加分回答</strong> </p><p>IoC是Java EE企业应用开发中的就偶组件之间复杂关系的利器。</p><p> 在以Spring为代表的轻量级Java EE开发风行之前,实际开发中是使用更多的是EJB为代表的开发模式。</p><p>在EJB开发模式中,开发人员需要编写EJB组件,这种组件需要满足EJB规范才能在EJB容器中运行,从而完成获取事务,生命周期管理等基本服务,Spring提供的服务和EJB并没有什么区别,只是在具体怎样获取服务的方式上两者的设计有很大不同：Spring IoC提供了一个基本的JavaBean容器,通过IoC模式管理依赖关系,并通过依赖注入和AOP切面增强了为JavaBean这样的POJO对象服务于事务管理、生命周期管理等基本功能；</p><p>而对于EJB,一个简单的EJB组件需要编写远程／本地接口、Home接口和Bean的实体类,而且EJB运行不能脱离EJB容器,查找其他EJB组件也需要通过诸如JNDI的方式,这就造成了对EJB容器和技术规范的依赖。也就是说Spring把EJB组件还原成了POJO对象或者JavaBean对象,以此降低了用用开发对于传统J2EE技术规范的依赖。 在应用开发中开发人员设计组件时往往需要引用和调用其他组件的服务,这种依赖关系如果固化在组件设计中,会造成依赖关系的僵化和维护难度的增加,这个时候使用IoC把资源获取的方向反转,让IoC容器主动管理这些依赖关系,将这些依赖关系注入到组件中,这就会让这些依赖关系的适配和管理更加灵活。</p><h3 id="说说Bean的生命周期"><a href="#说说Bean的生命周期" class="headerlink" title="说说Bean的生命周期"></a>说说Bean的生命周期</h3><p>解题思路</p><p>得分点 Spring Bean生命周期的四大部分以及详细步骤 </p><p><strong>标准回答</strong> </p><p>Bean 生命周期大致分为 Bean 定义、Bean 的初始化、Bean的生存期和 Bean 的销毁4个部分。具体步骤如下 </p><ol><li>Spring启动,查找并加载需要被Spring管理的bean,进行Bean的实例化 </li><li>Bean实例化后对将Bean的引入和值注入到Bean的属性中 </li><li>如果Bean实现了BeanNameAware接口的话,Spring将Bean的Id传递给setBeanName()方法 </li><li>如果Bean实现了BeanFactoryAware接口的话,Spring将调用setBeanFactory()方法,将BeanFactory容器实例传入 </li><li>如果Bean实现了ApplicationContextAware接口的话,Spring将调用Bean的setApplicationContext()方法,将bean所在应用上下文引用传入进来。 </li><li>如果Bean实现了BeanPostProcessor接口,Spring就将调用他们的postProcessBeforeInitialization()方法。 </li><li>如果Bean 实现了InitializingBean接口,Spring将调用他们的afterPropertiesSet()方法。类似的,如果bean使用init-method声明了初始化方法,该方法也会被调用 </li><li>如果Bean 实现了BeanPostProcessor接口,Spring就将调用他们的postProcessAfterInitialization()方法。</li><li>此时,Bean已经准备就绪,可以被应用程序使用了。他们将一直驻留在应用上下文中,直到应用上下文被销毁。 </li><li>如果bean实现了DisposableBean接口,Spring将调用它的destory()接口方法,同样,如果bean使用了destory-method 声明销毁方法,该方法也会被调用。</li></ol><p><strong>加分回答</strong> </p><p>这个过程是由Spring容器自动管理的,其中有两个环节我们可以进行干预。 </p><ol><li>我们可以自定义初始化方法,并在该方法前增加@PostConstruct注解,届时Spring容器将在调用SetBeanFactory方法之后调用该方法。</li><li>我们可以自定义销毁方法,并在该方法前增加@PreDestroy注解,届时Spring容器将在自身销毁前,调用这个方法。</li></ol><h3 id="说说-Autowired和-Resource注解的区别"><a href="#说说-Autowired和-Resource注解的区别" class="headerlink" title="说说@Autowired和@Resource注解的区别"></a>说说@Autowired和@Resource注解的区别</h3><p>解题思路</p><p>得分点 注解来源、注入方式 </p><p><strong>标准回答</strong> </p><ol><li>@Autowired是Spring提供的注解,@Resource是JDK提供的注解。</li><li>@Autowired是只能按类型注入,@Resource默认按名称注入,也支持按类型注入。</li><li>@Autowired按类型装配依赖对象,默认情况下它要求依赖对象必须存在,如果允许null值,可以设置它required属性为false,如果我们想使用按名称装配,可以结合@Qualifier注解一起使用。</li><li>@Resource有两个中重要的属性：name和type。name属性指定byName,如果没有指定name属性,当注解标注在字段上,即默认取字段的名称作为bean名称寻找依赖对象,当注解标注在属性的setter方法上,即默认取属性名作为bean名称寻找依赖对象。</li></ol><p><strong>加分回答</strong> </p><p>@Resource装配顺序 </p><ol><li>如果同时指定了name和type,则从Spring上下文中找到唯一匹配的bean进行装配,找不到则抛出异常</li><li>如果指定了name,则从上下文中查找名称（id）匹配的bean进行装配,找不到则抛出异常 </li><li>如果指定了type,则从上下文中找到类型匹配的唯一bean进行装配,找不到或者找到多个,都会抛出异常 </li><li>如果既没有指定name,又没有指定type,则自动按照byName方式进行装配；如果没有匹配,则回退为一个原始类型进行匹配,如果匹配则自动装配；</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/2023/01/27/Redis%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/Redis%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="详细的说说Redis的数据类型"><a href="#详细的说说Redis的数据类型" class="headerlink" title="详细的说说Redis的数据类型"></a>详细的说说Redis的数据类型</h3><p>解题思路</p><p>得分点 Redis5种数据结构 标准回答 Redis主要提供了5种数据结构：字符串(string)、哈希(hash)、列表(list)、集合(set)、有序集合(zset)。</p><p>Redis还提供了Bitmap、HyperLogLog、Geo类型,但这些类型都是基于上述核心数据类型实现的。</p><p>5.0版本中,Redis新增加了Streams数据类型,它是一个功能强大的、支持多播的、可持久化的消息队列。</p><p> string可以存储字符串、数字和二进制数据,除了值可以是String以外,所有的键也可以是string,string最大可以存储大小为2M的数据。</p><p> list保证数据线性有序且元素可重复,它支持lpush、blpush、rpop、brpop等操作,可以当作简单的消息队列使用,一个list最多可以存储2^32-1个元素 hash的值本身也是一个键值对结构,最多能存储2^32-1个元素 </p><p>set是无序不可重复的,它支持多个set求交集、并集、差集,适合实现共同关注之类的需求,一个set最多可以存储2^32-1个元素</p><p> zset是有序不可重复的,它通过给每个元素设置一个分数来作为排序的依据,一个zset最多可以存储2^32-1个元素。</p><p> 加分回答 每种类型支持多个编码,每一种编码采取一个特殊的结构来实现 各类数据结构内部的编码及结构：</p><p> string：编码分为int、raw、embstr；int底层实现为long,当数据为整数型并且可以用long类型表示时可以用long存储；embstr底层实现为占一块内存的SDS结构,当数据为长度不超过32字节的字符串时,选择以此结构连续存储元数据和值；</p><p>raw底层实现为占两块内存的SDS,用于存储长度超过32字节的字符串数据,此时会在两块内存中分别存储元数据和值。 list：编码分为ziplist、linkedlist和quicklist（3.2以前版本没有quicklist）。ziplist底层实现为压缩列表,当元素数量小于2且所有元素长度都小于64字节时,使用这种结构来存储；</p><p>linkedlist底层实现为双端链表,当数据不符合ziplist条件时,使用这种结构存储；3.2版本之后list一般采用quicklist的快速列表结构来代替前两种。</p><p> hash：编码分为ziplist、hashtable两种,其中ziplist底层实现为压缩列表,当键值对数量小于2,并且所有的键值长度都小于64字节时使用这种结构进行存储；</p><p>hashtable底层实现为字典,当不符合压缩列表存储条件时,使用字典进行存储。</p><p> set：编码分为inset和hashtable,intset底层实现为整数集合,当所有元素都是整数值且数量不超过2个时使用该结构存储,否则使用字典结构存储。 </p><p>zset：编码分为ziplist和skiplist,当元素数量小于128,并且每个元素长度都小于64字节时,使用ziplist压缩列表结构存储,否则使用skiplist的字典+跳表的结构存储。</p><h3 id="说说Redis的持久化策略"><a href="#说说Redis的持久化策略" class="headerlink" title="说说Redis的持久化策略"></a>说说Redis的持久化策略</h3><p>解题思路</p><p>得分点 RDB、AOF 标准回答 Redis4.0之后,Redis有RDB持久化、AOF持久化、RDB-AOF混合持久化这三种持久化方式。 RDB持久化是将当前进程数据以生成快照的方式保存到硬盘的过程,也是Redis默认的持久化机制。RDB会创建一个经过压缩的二进制文件,这个文件以’.rdb‘结尾,内部存储了各个数据库的键值对等信息。RDB持久化过程有手动触发和自动触发两种方式。手动触发是指通过SAVE或BGSAVE命令触发RDB持久化操作,创建“.rdb”文件；自动触发是指通过配置选项,让服务器在满足指定条件时自动执行BGSAVE命令。RDB持久化的优点是其生成的紧凑压缩的二进制文件体积小,使用该文件恢复数据的速度非常快；缺点则是BGSAVE每次运行都要执行fork操作创建子进程,这属于重量级操作,不宜频繁执行,因此,RBD没法做到实时的持久化。</p><p> AOF以独立日志的方式记录了每次写入的命令,重启时再重新执行AOF文件中的命令来恢复数据。AOF持久化的优点是与RDB持久化可能丢失大量的数据相比,AOF持久化的安全性要高很多。通过使用everysec选项,用户可以将数据丢失的时间窗口限制在1秒之内。其缺点则是,AOF文件存储的是协议文本,它的体积要比二进制格式的”.rdb”文件大很多。AOF需要通过执行AOF文件中的命令来恢复数据库,其恢复速度比RDB慢很多。AOF在进行重写时也需要创建子进程,在数据库体积较大时将占用大量资源,会导致服务器的短暂阻塞。AOF解决了数据持久化的实时性,是目前Redis主流的持久化方式。</p><p> RDB-AOF混合持久化模式是Redis4.0开始引入的,这种模式是基于AOF持久化构建而来的。用户可以通过配置文件中的“aof-use-rdb-preamble yes”配置项开启AOF混合持久化。Redis服务器在执行AOF重写操作时,会像执行BGSAVE命令一样,根据数据库当前的状态生成相应的RDB数据,并将其写入AOF文件中；对于重写之后执行的Redis命令,则以协议文本的方式追加到AOF文件的末尾,即RDB数据之后。 通过使用RDB-AOF混合持久化,用户可以同时获得RDB持久化和AOF持久化的优点,服务器既可以通过AOF文件包含的RDB数据来实现快速的数据恢复操作,又可以通过AOF文件包含的AOF数据来将丢失数据的时间窗口限制在1s之内 </p><p>加分回答 RDB手动触发分别对应save和bgsave命令：</p><ul><li>save 命令会一直阻塞当前Redis服务器到RBD过程完成为止,所以这种方式在操作内存比较大的实例时会造成长时间阻塞,因此线上环境不建议使用,该命令已经被废弃。 </li><li>bgsave命令会让Redis进程执行fork创建子进程,由子进程负责RBD持久化过程,完成后自动结束,因此只在fork阶段发生阻塞,一般阻塞的时间也不会很长。因此Redis内部所涉及的几乎所有RDB操作都采用了bgsave的方式。 除了执行命令手动触发之外,Redis内部还存在自动触发RDB的持久化机制,例如以下场景： </li><li><ol><li>使用save相关配置,如“save m n”。表示m秒内数据集存在n次修改 时,自动触发bgsave。</li><li>如果从节点执行全量复制操作,主节点自动执行bgsave生成RDB文件并发送给从节点。</li><li>执行debug reload命令重新加载Redis时,也会自动触发save操作。</li><li>默认情况下执行shutdown命令时,如果没有开启AOF持久化功能则 自动执行bgsave。</li></ol></li><li>AOF默认不开启,需要修改配置项来启用它： appendonly yes # 启用AOF appendfilename “appendonly.aof” # 设置文件名 AOF以文本协议格式写入命令,如： *3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n 文本协议格式具有如下的优点： </li><li><ol><li>文本协议具有很好的兼容性；</li><li>直接采用文本协议格式,可以避免二次处理的开销； </li><li>文本协议具有可读性,方便直接修改和处理。</li></ol></li><li>AOF持久化的文件同步机制： 为了提高程序的写入性能,现代操作系统会把针对硬盘的多次写操作优化为一次写操作。</li><li><ol><li>当程序调用write对文件写入时,系统不会直接把书记写入硬盘,而是先将数据写入内存的缓冲区中；</li><li>当达到特定的时间周期或缓冲区写满时,系统才会执行flush操作,将缓冲区中的数据冲洗至硬盘中； 这种优化机制虽然提高了性能,但也给程序的写入操作带来了不确定性。<ol><li>对于AOF这样的持久化功能来说,冲洗机制将直接影响AOF持久化的安全性； </li><li>为了消除上述机制的不确定性,Redis向用户提供了appendfsync选项,来控制系统冲洗AOF的频率；</li><li>Linux的glibc提供了fsync函数,可以将指定文件强制从缓冲区刷到硬盘,上述选项正是基于此函数。</li></ol></li></ol></li></ul><h3 id="如何利用Redis实现一个分布式锁？"><a href="#如何利用Redis实现一个分布式锁？" class="headerlink" title="如何利用Redis实现一个分布式锁？"></a>如何利用Redis实现一个分布式锁？</h3><p>解题思路</p><p>得分点 为什么要实现分布式锁、实现分布式锁的方式 </p><p>标准回答 </p><p>在分布式的环境下,会发生多个server并发修改同一个资源的情况,这种情况下,由于多个server是多个不同的JRE环境,而Java自带的锁局限于当前JRE,所以Java自带的锁机制在这个场景下是无效的,那么就需要我们自己来实现一个分布式锁。 </p><p>采用Redis实现分布式锁,我们可以在Redis中存一份代表锁的数据,数据格式通常使用字符串即可。 </p><p>首先加锁的逻辑可以通过<code>setnx key value</code>来实现,但如果客户端忘记解锁,那么这种情况就很有可能造成死锁,但如果直接给锁增加过期时间即新增<code>expire key seconds</code>又会发生其他问题,即这两个命令并不是原子性的,那么如果第二步失败,依然无法避免死锁问题。</p><p>考虑到如上问题,我们最终可以通过<code>set...nx...</code>命令,将加锁、过期命令编排到一起,把他们变成原子操作,这样就可以避免死锁。</p><p>写法为<code>set key value nx ex seconds</code> 。</p><p> 解锁就是将代表锁的那份数据删除,但不能用简单的<code>del key</code>,因为会出现一些问题。</p><p>比如此时有进程A,如果进程A在任务没有执行完毕时,锁被到期释放了。这种情况下进程A在任务完成后依然会尝试释放锁,因为它的代码逻辑规定它在任务结束后释放锁,但是它的锁早已经被释放过了,那这种情况它释放的就可能是其他线程的锁。</p><p>为解决这种情况,我们可以在加锁时为key赋一个随机值,来充当进程的标识,进程要记住这个标识。当进程解锁的时候进行判断,是自己持有的锁才能释放,否则不能释放。</p><p>另外判断,释放这两步需要保持原子性,否则如果第二步失败,就会造成死锁。而获取和删除命令不是原子的,这就需要采用Lua脚本,通过Lua脚本将两个命令编排在一起,而整个Lua脚本的执行是原子的。</p><p>综上所述,优化后的实现分布式锁命令如下： </p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 加锁 </span><br><span class="line">    set key <span class="built_in">random</span>-value nx ex seconds </span><br><span class="line"># 解锁 </span><br><span class="line">    <span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span> <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>]) <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span> <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p> <strong>加分回答</strong> </p><p>上述的分布式锁实现方式是建立在单节点之上的,它可能存在一些问题,比如有一种情况,进程A在主节点加锁成功,但主节点宕机了,那么从节点就会晋升为主节点。那如果此时另一个进程B在新的主节点上加锁成功而原主节点重启了,成为了从节点,系统中就会出现两把锁,这违背了锁的唯一性原则。 </p><p>总之,就是在单个主节点的架构上实现分布式锁,是无法保证高可用的。若要保证分布式锁的高可用,则可以采用多个节点的实现方案。这种方案有很多,而Redis的官方给出的建议是采用RedLock算法的实现方案。该算法基于多个Redis节点,它的基本逻辑如下： - 这些节点相互独立,不存在主从复制或者集群协调机制； </p><ul><li>加锁：以相同的KEY向N个实例加锁,只要超过一半节点成功,则认定加锁成功；</li><li>解锁：向所有的实例发送DEL命令,进行解锁； 我们可以自己实现该算法,也可以直接使用Redisson框架。</li></ul><h3 id="说说缓存穿透、击穿、雪崩的区别"><a href="#说说缓存穿透、击穿、雪崩的区别" class="headerlink" title="说说缓存穿透、击穿、雪崩的区别"></a>说说缓存穿透、击穿、雪崩的区别</h3><p>解题思路</p><p>得分点 三种问题的发生原因以及解决方式 </p><p><strong>标准回答</strong> </p><p><strong>缓存穿透：</strong>是指客户端查询了根本不存在的数据,使得这个请求直达存储层,导致其负载过大甚至造成宕机。这种情况可能是由于业务层误将缓存和库中的数据删除造成的,当然也不排除有人恶意攻击,专门访问库中不存在的数据导致缓存穿透。 我们可以通过缓存空对象的方式和布隆过滤器两种方式来解决这一问题。缓存空对象是指当存储层未命中后,仍然将空值存入缓存层 ,当客户端再次访问数据时,缓存层直接返回空值。还可以将数据存入布隆过滤器,访问缓存之前以过滤器拦截,若请求的数据不存在则直接返回空值。 </p><p><strong>缓存击穿：</strong>当一份访问量非常大的热点数据缓存失效的瞬间,大量的请求直达存储层,导致服务崩溃。 缓存击穿可以通过热点数据不设置过期时间来解决,这样就不会出现上述的问题,这是“物理”上的永不过期。或者为每个数据设置逻辑过期时间,当发现该数据逻辑过期时,使用单独的线程重建缓存。除了永不过期的方式,我们也可以通过加互斥锁的方式来解决缓存击穿,即对数据的访问加互斥锁,当一个线程访问该数据时,其他线程只能等待。这个线程访问过后,缓存中的数据将被重建,届时其他线程就可以直接从缓存中取值。 </p><p><strong>缓存雪崩：</strong>是指当某一时刻缓存层无法继续提供服务,导致所有的请求直达存储层,造成数据库宕机。可能是缓存中有大量数据同时过期,也可能是Redis节点发生故障,导致大量请求无法得到处理。 </p><p>缓存雪崩的解决方式有三种；</p><p>第一种是在设置过期时间时,附加一个随机数,避免大量的key同时过期。</p><p>第二种是启用降级和熔断措施,即发生雪崩时,若应用访问的不是核心数据,则直接返回预定义信息&#x2F;空值&#x2F;错误信息。或者在发生雪崩时,对于访问缓存接口的请求,客户端并不会把请求发给Redis,而是直接返回。</p><p>第三种是构建高可用的Redis服务,也就是采用哨兵或集群模式,部署多个Redis实例,这样即使个别节点宕机,依然可以保持服务的整体可用。</p><h3 id="Redis如何与数据库保持双写一致性"><a href="#Redis如何与数据库保持双写一致性" class="headerlink" title="Redis如何与数据库保持双写一致性"></a>Redis如何与数据库保持双写一致性</h3><p>解题思路</p><p>得分点 四种同步策略及其可能出现的问题,重试机制 </p><p><strong>标准回答</strong> </p><p>保证缓存和数据库的双写一致性,共有四种同步策略,即先更新缓存再更新数据库、先更新数据库再更新缓存、先删除缓存再更新数据库、先更新数据库再删除缓存。 </p><p>先更新缓存的优点是每次数据变化时都能及时地更新缓存,这样不容易出现查询未命中的情况,但这种操作的消耗很大,如果数据需要经过复杂的计算再写入缓存的话,频繁的更新缓存会影响到服务器的性能。如果是写入数据比较频繁的场景,可能会导致频繁的更新缓存却没有业务来读取该数据。 </p><p>删除缓存的优点是操作简单,无论更新的操作复杂与否,都是直接删除缓存中的数据。这种做法的缺点则是,当删除了缓存之后,下一次查询容易出现未命中的情况,那么这时就需要再次读取数据库。 那么对比而言,删除缓存无疑是更好的选择。 </p><p>那么我们再来看一下先操作数据库和后操作数据库的区别；</p><p>先删除缓存再操作数据库的话,如果第二步骤失败可能导致缓存和数据库得到相同的旧数据。</p><p>先操作数据库但删除缓存失败的话则会导致缓存和数据库得到的结果不一致。</p><p>出现上述问题的时候,我们一般采用重试机制解决,而为了避免重试机制影响主要业务的执行,一般建议重试机制采用异步的方式执行。</p><p>当我们采用重试机制之后由于存在并发,先删除缓存依然可能存在缓存中存储了旧的数据,而数据库中存储了新的数据,二者数据不一致的情况。 </p><p>所以我们得到结论：先更新数据库、再删除缓存是影响更小的方案。如果第二步出现失败的情况,则可以采用重试机制解决问题。</p><h3 id="请你说说Redis数据类型中的zset-它和set有什么区别？底层是怎么实现的？"><a href="#请你说说Redis数据类型中的zset-它和set有什么区别？底层是怎么实现的？" class="headerlink" title="请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？"></a>请你说说Redis数据类型中的zset,它和set有什么区别？底层是怎么实现的？</h3><p>解题思路</p><p>得分点 有序无序、底层结构 </p><p><strong>标准回答</strong> </p><p>Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。不同的是每个元素都会关联一个 double 类型的分数Redis 正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数 ( score ) 却可以重复。集合是通过哈希表实现的,所以添加,删除,查找的复杂度都是 O(1)。集合中最大的成员数为 232 – 1 ( 4294967295 ) , 每个集合可存储 40 多亿个成员。 zset底层的存储结构包括ziplist或skiplist,在同时满足有序集合保存的元素数量小于128个和有序集合保存的所有元素的长度小于64字节的时候使用ziplist,其他时候使用skiplist。 当ziplist作为zset的底层存储结构时候,每个集合元素使用两个紧挨在一起的压缩列表节点来保存,第一个节点保存元素的成员,第二个元素保存元素的分值。 当skiplist作为zset的底层存储结构的时候,使用skiplist按序保存元素及分值,使用dict来保存元素和分值的映射关系。 </p><p><strong>加分回答</strong> </p><p>实际上单独使用Hashmap或skiplist也可以实现有序集合,Redis使用两种数据结构组合的原因是</p><p>如果我们单独使用Hashmap,虽然能以O(1) 的时间复杂度查找成员的分值,但是因为Hashmap是以无序的方式来保存集合元素,所以每次进行范围操作的时候都要进行排序；</p><p>而如果单独使用skiplist,虽然能执行范围操作,但查找操作的复杂度却由 O(1)变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。</p><h3 id="说说Redis的单线程架构"><a href="#说说Redis的单线程架构" class="headerlink" title="说说Redis的单线程架构"></a>说说Redis的单线程架构</h3><p>解题思路</p><p>得分点 单线程的前提,单线程的优劣,简单的io模型 </p><p><strong>标准回答</strong> </p><p>Redis的网络IO和键值对读写是由一个线程来完成的,但Redis的其他功能,例如持久化、异步删除、集群数据同步等操作依赖于其他线程来执行。单线程可以简化数据结构和算法的实现,并且可以避免线程切换和竞争造成的消耗。但要注意如果某个命令执行时间过长,会造成其他命令的阻塞。Redis采用了io多路复用机制,这带给了Redis并发处理大量客户端请求的能力。 Redis单线程实现为什么这么快呢？因为对服务端程序来说,线程切换和锁通常是性能杀手,而单线程避免了线程切换和竞争所产生的消耗。另外Redis的大部分操作是在内存上完成的,这是它实现高性能的一个重要原因；Redis还采用了IO多路复用机制,使其在网络IO操作中能并发处理大量的客户端请求,实现高吞吐率。 </p><p><strong>加分回答</strong> </p><p>Redis的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的。而Redis的其他功能,如持久化、异步删除、集群数据同步等,则是依赖其他线程来执行的。所以,说Redis是单线程的只是一种习惯的说法,事实上它的底层不是单线程的。</p><h3 id="如何实现Redis高可用"><a href="#如何实现Redis高可用" class="headerlink" title="如何实现Redis高可用"></a>如何实现Redis高可用</h3><p>解题思路</p><p>得分点 哨兵模式、集群模式 标准回答 主要有哨兵和集群两种方式可以实现Redis高可用。 哨兵： 哨兵模式是Redis的高可用的解决方案,它由一个或多个Sentinel实例组成Sentinel系统,可以监视任意多个主服务器以及这些主服务器属下的所有从服务器。当哨兵节点发现有节点不可达时,会对该节点做下线标识。如果是主节点下线,它还会和其他Sentinel节点进行“协商”,当大多数Sentinel节点都认为主节点不可达时,它们会选举出一个Sentinel节点来完成自动故障转移的工作,同时会将这个变化实时通知给Redis应用方。 哨兵节点包含如下的特征：</p><ol><li>哨兵节点会定期监控数据节点,其他哨兵节点是否可达；</li><li>哨兵节点会将故障转移的结果通知给应用方；</li><li>哨兵节点可以将从节点晋升为主节点,并维护后续正确的主从关系；</li><li>哨兵模式下,客户端连接的是哨兵节点集合,从中获取主节点信息；</li><li>节点的故障判断是由多个哨兵节点共同完成的,可有效地防止误判；</li><li>哨兵节点集合是由多个哨兵节点组成的,即使个别哨兵节点不可用,整个集合依然是健壮的；</li><li>哨兵节点也是独立的Redis节点,是特殊的Redis节点,它们不存储数据,只支持部分命令。 集群： Redis集群采用虚拟槽分区来实现数据分片,它把所有的键根据哈希函数映射到<code>0-16383</code>整数槽内,计算公式为<code>slot=CRC16(key)&amp;16383</code>,每一个节点负责维护一部分槽以及槽所映射的键值数据。虚拟槽分区具有如下特点：。</li><li>解耦数据和节点之间的关系,简化了节点扩容和收缩的难度；</li><li>节点自身维护槽的映射关系,不需要客户端或者代理服务维护槽分区元数据；</li><li>支持节点、槽、键之间的映射查询,用于数据路由,在线伸缩等场景。</li></ol><h3 id="说说Redis的主从同步机制"><a href="#说说Redis的主从同步机制" class="headerlink" title="说说Redis的主从同步机制"></a>说说Redis的主从同步机制</h3><p>解题思路</p><p>得分点 psync,全量复制、部分复制 </p><p><strong>标准回答</strong> </p><p>Redis主从同步是指任意数量的从节点（slave node）都可以从主节点上（master node）同步数据。而除了多个 slave 可以连接到同一个 master 之外,slave 还可以接受其他 slave 的连接,这就形成一个树形结构,使得Redis可执行单层树复制。 从2.8版本开始,当启动一个 slave node 的时候,它会发送一个 <code>PSYNC</code> 命令给 master node。如果slave node 是第一次连接到 master node,那么会触发一次全量复制。此时 master 会启动一个后台线程,开始生成一份 <code>RDB</code> 快照文件,同时还会将从客户端 client 新收到的所有写命令缓存在内存中。<code>RDB</code> 文件生成完毕后, master 会将这个 <code>RDB</code> 发送给 slave,slave 会先写入本地磁盘,然后再从本地磁盘加载到内存中,接着 master 会将内存中缓存的写命令发送到 slave,slave 也会同步这些数据。slave node 如果跟 master node 有网络故障,断开了连接,会自动重连,连接之后 master node 仅会复制给 slave 部分缺少的数据。</p><h3 id="说说Redis的缓存淘汰策略"><a href="#说说Redis的缓存淘汰策略" class="headerlink" title="说说Redis的缓存淘汰策略"></a>说说Redis的缓存淘汰策略</h3><p>解题思路</p><p>得分点 惰性删除、定期删除,maxmemory-policy </p><p>标准回答</p><p> Redis有如下两种过期策略： </p><p>惰性删除：客户端访问一个key的时候,Redis会先检查它的过期时间,如果发现过期就立刻删除这个key。 </p><p>定期删除：Redis会将设置了过期时间的key放到一个独立的字典中,并对该字典进行每秒10次的过期扫描, 过期扫描不会遍历字典中所有的key,而是采用了一种简单的贪心策略。</p><ul><li>该策略的删除逻辑如下：</li></ul><ol><li>从过期字典中随机选择20个key； </li><li>删除这20个key中已过期的key； </li><li>如果已过期key的比例超过25%,则重复步骤1。</li></ol><p>当写入数据将导致超出maxmemory限制时,Redis会采用maxmemory-policy所指定的策略进行数据淘汰,该策略一共包含8种选项,其中除了noeviction直接返回错误之外,筛选键的方式分为volatile和allkeys两种,volatile前缀代表从设置了过期时间的键中淘汰数据,allkeys前缀代表从所有的键中淘汰数据关于后缀,ttl代表选择过期时间最小的键,random代表随机选择键,需要我们额外关注的是lru和lfu后缀,它们分别代表采用lru算法和lfu算法来淘汰数据。因为allkeys是筛选所有的键,所以不存在ttl,余下三个后缀二者都有,lfu算法是再Redis4版本才提出来的。 </p><p><strong>加分回答</strong></p><p> LRU（Least Recently Used）是按照最近最少使用原则来筛选数据,即最不常用的数据会被筛选出来 - 标准LRU：把所有的数据组成一个链表,表头和表尾分别表示MRU和LRU端,即最常使用端和最少使用端。刚被访问的数据会被移动到MRU端,而新增的数据也是刚被访问的数据,也会被移动到MRU端。当链表的空间被占满时,它会删除LRU端的数据。 - 近似LRU：Redis会记录每个数据的最近一次访问的时间戳（LRU）。Redis执行写入操作时,若发现内存超出maxmemory,就会执行一次近似LRU淘汰算法。近似LRU会随机采样N个key,然后淘汰掉最旧的key,若淘汰后内存依然超出限制,则继续采样淘汰。可以通过maxmemory_samples配置项,设置近似LRU每次采样的数据个数,该配置项的默认值为5。 LRU算法的不足之处在于,若一个key很少被访问,只是刚刚偶尔被访问了一次,则它就被认为是热点数据,短时间内不会被淘汰。 LFU算法正式用于解决上述问题,LFU（Least Frequently Used）是Redis4新增的淘汰策略,它根据key的最近访问频率进行淘汰。LFU在LRU的基础上,为每个数据增加了一个计数器,来统计这个数据的访问次数。当使用LFU策略淘汰数据时,首先会根据数据的访问次数进行筛选,把访问次数最低的数据淘汰出内存。如果两个数据的访问次数相同,LFU再比较这两个数据的访问时间,把访问时间更早的数据淘汰出内存。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/2023/01/27/MySQL%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/MySQL%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请你说说MySQL索引-以及它们的好处和坏处"><a href="#请你说说MySQL索引-以及它们的好处和坏处" class="headerlink" title="请你说说MySQL索引,以及它们的好处和坏处"></a>请你说说MySQL索引,以及它们的好处和坏处</h3><p>解题思路</p><p>得分点 检索效率、存储资源、索引维护 标准回答 索引就像指向表行的指针,是一种允许查询操作快速确定哪些行符合WHERE子句中的条件,并检索到这些行的其他列值的数据结构；</p><p> 索引主要有普通索引、唯一索引、主键索引、外键索引、全文索引、复合索引几种； 在大数据量的查询中,合理使用索引的优点非常明显,不仅能大幅提高匹配where条件的检索效率,还能用于排序和分组操作的加速。 当时索引如果使用不当也有比较大的坏处：比如索引必定会增加存储资源的消耗；同时也增大了插入、更新和删除操作的维护成本,因为每个增删改操作后相应列的索引都必须被更新。 加分回答 只要创建了索引,就一定会走索引吗？ 不一定。 比如,在使用组合索引的时候,如果没有遵从“最左前缀”的原则进行搜索,则索引是不起作用的。 举例,假设在id、name、age字段上已经成功建立了一个名为MultiIdx的组合索引。索引行中按id、name、age的顺序存放,索引可以搜索id、（id,name）、（id, name, age）字段组合。如果列不构成索引最左面的前缀,那么MySQL不能使用局部索引,如（age）或者（name,age）组合则不能使用该索引查询。</p><h3 id="请你说说MySQL的事务隔离级别"><a href="#请你说说MySQL的事务隔离级别" class="headerlink" title="请你说说MySQL的事务隔离级别"></a>请你说说MySQL的事务隔离级别</h3><p>解题思路</p><p>得分点 未提交读、已提交读、可重复读、可串行化 </p><p>标准回答 </p><p>SQL 标准定义了四种隔离级别,这四种隔离级别分别是： </p><ul><li>读未提交（READ UNCOMMITTED）；</li><li>读提交 （READ COMMITTED）；</li><li>可重复读 （REPEATABLE READ）； </li><li>串行化 （SERIALIZABLE）。</li></ul><p>事务隔离是为了解决脏读、不可重复读、幻读问题,下表展示了 4 种隔离级别对这三个问题的解决程度：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>READ COMMITTED</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>REPEATABLE READ</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>SERIALIZABLE</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p>上述4种隔离级别MySQL都支持,并且InnoDB存储引擎默认的支持隔离级别是REPEATABLE READ,但是与标准SQL不同的是,InnoDB存储引擎在REPEATABLE READ事务隔离级别下,使用Next-Key Lock的锁算法,因此避免了幻读的产生。</p><p>所以,InnoDB存储引擎在默认的事务隔离级别下已经能完全保证事务的隔离性要求,即达到SQL标准的SERIALIZABLE隔离级别； </p><p><strong>加分回答</strong> </p><p>READ UNCOMMITTED： 它是性能最好、也最野蛮的方式,因为它压根儿就不加锁,所以根本谈不上什么隔离效果,可以理解为没有隔离。</p><p> SERIALIZABLE： 读的时候加共享锁,其他事务可以并发读,但是不能写。写的时候加排它锁,其他事务不能并发写也不能并发读。 </p><p>REPEATABLE READ &amp; READ COMMITTED： 为了解决不可重复读,MySQL 采用了 MVVC (多版本并发控制) 的方式。 我们在数据库表中看到的一行记录可能实际上有多个版本,每个版本的记录除了有数据本身外,还要有一个表示版本的字段,记为 row trx_id,而这个字段就是使其产生的事务的 id,事务 ID 记为 transaction id,它在事务开始的时候向事务系统申请,按时间先后顺序递增。</p><ul><li><blockquote><p>脏读 (Dirty Read): 脏读是指当一个事务正在修改数据时，另一个事务读取了这个数据，而这个数据可能还没有被提交或回滚，这样就会读取到不正确的数据。</p></blockquote></li><li><blockquote><p>不可重复读 (Non-Repeatable Read): 不可重复读是指在一个事务中多次读取同一数据，但是由于其他事务对数据的修改，导致读取到不同的数据。</p></blockquote></li><li><blockquote><p>幻读 (Phantom Read): 幻读是指在一个事务中多次读取同一数据集，但是由于其他事务对数据集中数据的增加或删除，导致读取到不同的数据集。</p></blockquote></li></ul><h3 id="请你说说聚簇索引和非聚簇索引"><a href="#请你说说聚簇索引和非聚簇索引" class="headerlink" title="请你说说聚簇索引和非聚簇索引"></a>请你说说聚簇索引和非聚簇索引</h3><p>解题思路</p><p>得分点 索引即数据、二次查询 </p><p><strong>标准回答</strong></p><p> 两者主要区别是数据和索引是否分离。</p><p>聚簇索引是将数据与索引存储到一起,找到索引也就找到了数据；</p><p>而非聚簇索引是将数据和索引存储分离开,索引树的叶子节点存储了数据行的地址。</p><p> 在InnoDB中,一个表有且仅有一个聚簇索引（因为原始数据只留一份,而数据和聚簇索引在一起）,并且该索引是建立在主键上的,即使没有指定主键,也会特殊处理生成一个聚簇索引；其他索引都是辅助索引,使用辅助索引访问索引外的其他字段时都需要进行二次查找。 而在MyISAM中,所有索引都是非聚簇索引,叶子节点存储着数据的地址,对于主键索引和普通索引在存储上没有区别。 </p><p><strong>加分回答</strong> </p><p>在InnoDB存储引擎中,可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。</p><p>无论是何种索引,每个页的大小都为16KB,且不能更改。 </p><p>聚簇索引是根据主键创建的一棵B+树,聚簇索引的叶子节点存放了表中的所有记录。</p><p>辅助索引是根据索引键创建的一棵B+树,与聚簇索引不同的是,其叶子节点仅存放索引键值,以及该索引键值指向的主键。</p><p>也就是说,如果通过辅助索引来查找数据,那么当找到辅助索引的叶子节点后,很有可能还需要根据主键值查找聚簇索引来得到数据,这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据,这就意味着每页可以存放更多的键值,因此其高度一般都要小于聚簇索引。</p><h3 id="数据库为什么不用红黑树而用B-树？"><a href="#数据库为什么不用红黑树而用B-树？" class="headerlink" title="数据库为什么不用红黑树而用B+树？"></a>数据库为什么不用红黑树而用B+树？</h3><p>解题思路</p><p>得分点 磁盘IO </p><p><strong>标准回答</strong> </p><p>首先,红黑树是一种近似平衡二叉树（不完全平衡）,结点非黑即红的树,它的树高最高不会超过 2*log(n),因此查找的时间复杂度为 O(log(n)),无论是增删改查,它的性能都十分稳定； </p><p>但是,红黑树本质还是二叉树,在数据量非常大时,需要访问+判断的节点数还是会比较多,同时数据是存在磁盘上的,访问需要进行磁盘IO,导致效率较低； </p><p>而B+树是多叉的,可以有效减少磁盘IO次数；</p><p>同时B+树增加了叶子结点间的连接,能保证范围查询时找到起点和终点后快速取出需要的数据。</p><p> <strong>加分回答</strong></p><p>红黑树做索引底层数据结构的缺陷 试想一下,以红黑树作为底层数据结构在面对在些表数据动辄数百万数千万的场景时,创建的索引它的树高得有多高？ </p><p>索引从根节点开始查找,而如果我们需要查找的数据在底层的叶子节点上,那么树的高度是多少,就要进行多少次查找,数据存在磁盘上,访问需要进行磁盘IO,这会导致效率过低； </p><p>那么红黑树作为索引数据结构的弊端即是：树的高度过高导致查询效率变慢。</p><h3 id="请你说说innodb和myisam的区别？"><a href="#请你说说innodb和myisam的区别？" class="headerlink" title="请你说说innodb和myisam的区别？"></a>请你说说innodb和myisam的区别？</h3><p>解题思路</p><p>得分点 事务、锁、读写性能、存储结构 </p><p><strong>标准回答</strong> </p><p>InnoDB是具有事务、回滚和崩溃修复能力的事务安全型引擎,它可以实现行级锁来保证高性能的大量数据中的并发操作；MyISAM是具有默认支持全文索引、压缩功能及较高查询性能的非事务性引擎。</p><p>具体来说,可以在以下角度上形成对比： </p><p>事务：</p><p>InnoDB支持事务；</p><p>MyISAM不支持。 </p><p>数据锁：</p><p>InnoDB支持行级锁；</p><p>MyISAM只支持表级锁。 </p><p>读写性能：</p><p>InnoDB增删改性能更优；</p><p>MyISAM查询性能更优。 </p><p>全文索引：</p><p>InnoDB不支持（但可通过插件等方式支持）；</p><p>MyISAM默认支持。 </p><p>外键：</p><p>InnoDB支持外键；</p><p>MyISAM不支持。 </p><p>存储结构：</p><p>InnoDB在磁盘存储为一个文件；</p><p>MyISAM在磁盘上存储成三个文件（表定义、数据、索引）。 </p><p>存储空间：</p><p>InnoDB需要更多的内存和存储；</p><p>MyISAM支持支持三种不同的存储格式：静态表(默认)、动态表、压缩表。 </p><p>移植：</p><p>InnoDB在数据量小时可通过拷贝数据文件、备份 binlog、mysqldump工具移植,数据量大时比较麻烦；</p><p>可单独对某个表通过拷贝表文件移植。 </p><p>崩溃恢复：</p><p>InnoDB有崩溃恢复机制；</p><p>MyISAM没有。 </p><p>默认推荐：</p><p>InnoDB是MySQL5.5之后的默认引擎。 </p><p><strong>加分回答</strong> </p><p>InnoDB中行级锁是怎么实现的？ </p><p>InnoDB行级锁是通过给索引上的索引项加锁来实现的。</p><p>只有通过索引条件检索数据,InnoDB才使用行级锁,否则,InnoDB将使用表锁。 </p><p>当表中锁定其中的某几行时,不同的事务可以使用不同的索引锁定不同的行。另外,不论使用主键索引、唯一索引还是普通索引,InnoDB都会使用行锁来对数据加锁。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2023/01/27/JVM%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/JVM%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="说说你了解的JVM内存模型"><a href="#说说你了解的JVM内存模型" class="headerlink" title="说说你了解的JVM内存模型"></a>说说你了解的JVM内存模型</h3><p>解题思路</p><p>得分点 类加载子系统、执行引擎、运行时数据区 </p><p><strong>标准回答</strong> </p><p>JVM由三部分组成：类加载子系统、执行引擎、运行时数据区。 </p><ol><li>类加载子系统,可以根据指定的全限定名来载入类或接口。 </li><li>执行引擎,负责执行那些包含在被载入类的方法中的指令。 </li><li>当程序运行时,JVM需要内存来存储许多内容,例如：字节码、对象、参数、返回值、局部变量、运算的中间结果,等等,JVM会把这些东西都存储到运行时数据区中,以便于管理。</li><li>而运行时数据区又可以分为方法区、堆、虚拟机栈、本地方法栈、程序计数器。</li></ol><p><strong>加分回答</strong> </p><p>运行时数据区是开发者重点要关注的部分,因为程序的运行与它密不可分,很多错误的排查也需要基于对运行时数据区的理解。在运行时数据区所包含的几块内存空间中,方法区和堆是线程之间共享的内存区域,<strong>而虚拟机栈、本地方法栈、程序计数器则是线程私有的区域,就是说每个线程都有自己的这个区域。</strong></p><h3 id="说说JVM的垃圾回收机制"><a href="#说说JVM的垃圾回收机制" class="headerlink" title="说说JVM的垃圾回收机制"></a>说说JVM的垃圾回收机制</h3><p>解题思路</p><p>得分点 新生代收集、老年代收集、混合收集、整堆收集 </p><p><strong>标准回答</strong> </p><p>当前商业虚拟机的垃圾收集器,大多数都遵循了“分代收集”的理论进行设计,分代收集名为理论,实质是一套符合大多数程序运行实际情况的经验法则。而分代收集理论,建立在如下三个分代假说之上,即弱分代假说、强分代假说、跨代引用假说。依据分代假说理论,垃圾回收可以分为如下几类： </p><ol><li>新生代收集：目标为新生代的垃圾收集。 </li><li>老年代收集：目标为老年代的垃圾收集,目前只有CMS收集器会有这种行为。 </li><li>混合收集：目标为整个新生代及部分老年代的垃圾收集,目前只有G1收集器会有这种行为。 </li><li>整堆收集：目标为整个堆和方法区的垃圾收集。</li></ol><p><strong>加分回答</strong> </p><p>HotSpot虚拟机内置了很多垃圾收集器,</p><p>其中针对新生代的垃圾收集器有Serial、ParNew、Parallel Scavenge,</p><p>针对老年代的垃圾收集器有CMS、Serial Old、Parallel Old。</p><p>此外,HotSpot还内置了面向整堆的G1收集器。在上述收集器中,常见的组合方式有： </p><ol><li>Serial + Serial Old,是客户端模式下常用的收集器。</li><li>ParNew + CMS,是服务端模式下常用的收集器。 </li><li>Parallel Scavenge + Parallel Old,适用于后台运算而不需要太多交互的分析任务。</li></ol><h3 id="请你说说Java的四种引用方式"><a href="#请你说说Java的四种引用方式" class="headerlink" title="请你说说Java的四种引用方式"></a>请你说说Java的四种引用方式</h3><p>解题思路</p><p>得分点 强引用、软引用、弱引用、虚引用 </p><p><strong>标准回答</strong> </p><p>在JDK 1.2版之前,一个对象只有“被引用”或者“未被引用”两种状态,对于描述一些“不太重要”的对象就显得无能为力。</p><p>譬如我们希望能描述一类对象：当内存空间还足够时,能保留在内存之中,如果内存空间在进行垃圾收集后仍然非常紧张,那就可以抛弃这些对象。很多系统的缓存功能都符合这样的应用场景。</p><p>在JDK 1.2版之后,Java对引用的概念进行了扩充,将引用分为分为强引用、软引用、弱引用、虚引用4种,这4种引用强度依次逐渐减弱。 </p><p>强引用是最传统的“引用”的定义,是指在程序代码之中普遍存在的引用赋值,即类似“Object obj&#x3D;new Object()”这种引用关系。无论任何情况下,只要强引用关系还存在,垃圾收集器就永远不会回收掉被引用的对象。</p><p>软引用是用来描述一些还有用,但非必须的对象。只被软引用关联着的对象,在系统将要发生内存溢出异常前,会把这些对象列进回收范围之中进行第二次回收,如果这次回收还没有足够的内存,才会抛出内存溢出异常。 </p><p>弱引用也是用来描述那些非必须的对象,但是它的强度比软引用更弱一些,被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作,无论当前内存是否足够,都会回收掉只被弱引用关联的对象。 </p><p>虚引用是最弱的一种引用关系。一个对象是否有虚引用的存在,完全不会对其生存时间构成影响,也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p><h3 id="请你讲下G1垃圾回收器"><a href="#请你讲下G1垃圾回收器" class="headerlink" title="请你讲下G1垃圾回收器"></a>请你讲下G1垃圾回收器</h3><p>解题思路</p><p>得分点 整堆、Region、标记整理、四个步骤 </p><p><strong>标准回答</strong> </p><p>Garbage First（G1）收集器开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。</p><p>在G1收集器出现之前的所有其他收集器,垃圾收集的目标范围要么是整个新生代,要么就是整个老年代,再要么就是整个Java堆。</p><p>而G1跳出了这个限制,它可以面向堆内存任何部分来组成回收集进行回收,衡量标准不再是它属于哪个分代,而是哪块内存中存放的垃圾数量最多,回收收益最大,这就是G1收集器的Mixed GC模式。 </p><p>G1也仍是遵循分代收集理论设计的,但其堆内存的布局与其他收集器有非常明显的差异：</p><p>G1不再坚持固定大小以及固定数量的分代区域划分,而是把连续的Java堆划分为多个大小相等的独立区域（Region）,每一个Region都可以根据需要,扮演新生代的Eden空间、Survivor空间,或者老年代空间。 </p><p>此外,还有一类专门用来存储大对象的特殊区域（Humongous Region）。</p><p>G1认为只要超过了Region一半的对象即可判定为大对象。而对于那些超过了整个Region容量的超级大对象,将会被存放在N个连续的Humongous Region之中,G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。 </p><p>更具体的处理思路是,让G1收集器去跟踪各个Region里面的垃圾堆积的“价值”大小,价值即回收所获得的空间大小以及回收所需时间的经验值,然后在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间,优先处理回收价值收益最大的那些Region,这也就是“Garbage First”名字的由来。 </p><p>G1收集器的运作过程大致可划分为以下四个步骤：</p><p>初始标记、并发标记、最终标记、筛选回收。</p><p>其中,初始标记和最终标记阶段仍然需要停顿所有的线程,但是耗时很短。 </p><p><strong>加分回答</strong> </p><p>G1与CMS的对比： G1从整体来看是基于标记整理算法实现的收集器,但从局部上看又是基于标记复制算法实现。无论如何,这两种算法都意味着G1运作期间不会产生内存空间碎片,垃圾收集完成之后能提供规整的可用内存。比起CMS,G1的弱项也可以列举出不少。例如在用户程序运行过程中,G1无论是为了垃圾收集产生的内存占用还是程序运行时的额外执行负载都要比CMS要高。 G1与CMS的选择： 目前在小内存应用上CMS的表现大概率仍然要会优于G1,而在大内存应用上G1则大多能发挥其优势,这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。以上这些也仅是经验之谈,随着HotSpot的开发者对G1的不断优化,也会让对比结果继续向G1倾斜。</p><h3 id="请你说说内存泄漏"><a href="#请你说说内存泄漏" class="headerlink" title="请你说说内存泄漏"></a>请你说说内存泄漏</h3><p>解题思路</p><p>得分点 分析器、详细日志、引用对象、泄漏警告、基准测试、代码审查 </p><p><strong>标准回答</strong> </p><p>内存泄漏,是指不再使用的对象仍然被引用,导致垃圾收集器无法回收它们的内存。由于不再使用的对象仍然无法清理,甚至这种情况可能会越积越多,最终导致致命的OutOfMemoryError。</p><p>可以按照如下的思路来分析和解决内存泄漏问题： </p><ol><li>启用分析器 Java分析器是通过应用程序监视和诊断内存泄漏的工具,它可以分析我们的应用程序内部发生的事情,例如如何分配内存。使用分析器,我们可以比较不同的方法并找到可以最佳利用资源的方式。 </li><li>启用详细垃圾收集日志 通过启用详细垃圾收集日志,我们可以跟踪GC的详细进度。要启用该功能,我们需要将以下内容添加到JVM的配置当中：<code>-verbose:gc</code>。通过这个参数,我们可以看到GC内部发生的细节。 </li><li>使用引用对象 我们还可以借助java.lang.ref包内置的Java引用对象来规避问题,使用java.lang.ref包,而不是直接引用对象,即使用对象的特殊引用,使得它们可以轻松地被垃圾收集。 </li><li>Eclipse内存泄漏警告 对于JDK1.5以及更高的版本中,Eclipse会在遇到明显的内存泄漏情况时显示警告和错误。因此,在Eclipse中开发时,我们可以定期地访问“问题”选项卡,并更加警惕内存泄漏警告。 </li><li>基准测试 我们可以通过执行基准测试来衡量和分析Java代码的性能。通过这种方式,我们可以比较执行相同任务的替代方法的性能。这可以帮助我们选择更好的方法,并可以帮助我们节约内存。 </li><li>代码审查 最后,我们总是采用经典的老方式来进行简单的代码演练。在某些情况下,即使这种看似微不足道的方法也有助于消除一些常见的内存泄漏问题。</li></ol><p><strong>加分回答</strong> </p><p>通俗地说,我们可以将内存泄漏视为一种疾病,它通过阻塞重要的内存资源来降低应用程序的性能。</p><p>和所有其他疾病一样,如果不治愈,随着时间的推移,它可能导致致命的应用程序崩溃。 </p><p>内存泄漏很难解决,找到它们需要对Java语言有很深的理解并掌握复杂的命令。</p><p>在处理内存泄漏时,没有一刀切的解决方案,因为泄漏可能通过各种不同的事件发生。 </p><p>但是,如果我们采用最佳实践并定期执行严格的代码演练和分析,那么我们就可以将应用程序中内存泄漏的风险降到最低。</p><h3 id="说说垃圾收集器"><a href="#说说垃圾收集器" class="headerlink" title="说说垃圾收集器"></a>说说垃圾收集器</h3><p>解题思路</p><p>得分点<br>Serial、Serial Old、PawNew、CMS、Parallel Scavenge、Parallel Old、G1</p><p>标准回答</p><p>《Java虚拟机规范》中对垃圾收集器应该如何实现并没有做出任何规定，因此不同的厂商、不同版本的虚拟机所包含的垃圾收集器都可能会有很大差别，不同的虚拟机一般也都会提供各种参数供用户根据自己的应用特点和要求组合出各个内存分代所使用的收集器。下图是HotSpot虚拟机中包含的垃圾收集器，图中展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220226/4107856_1645862288202/E27EB6FDAD1AE8A06C61CCE2BCB51FF1" alt="img"></p><p>Serial收集器是最基础、历史最悠久的收集器，曾经是HotSpot虚拟机新生代收集器的唯一选择。这个收集器是一个单线程工作的收集器，但它的“单线程”的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。也就是说它在进行垃圾收集时，会发生“Stop The World”。</p><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。<br>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是能够并行收集的多线程收集器。它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。<br>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法，这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。<br>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。<br>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，从名字上就可以看出CMS收集器是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为四个步骤，包括：初始标记、并发标记、重新标记、并发清除。<br>Garbage First（简称G1）收集器是垃圾收集器技术发展历史上的里程碑式的成果，它开创了收集器面向局部收集的设计思路和基于Region的内存布局形式。到了JDK 8 Update 40的时候，G1提供并发的类卸载的支持，补全了其计划功能的最后一块拼图。这个版本以后的G1收集器才被Oracle官方称为“全功能的垃圾收集器”。</p><p><strong>加分回答</strong><br>通常，Serial收集器搭配Serial Old使用，ParNew收集器搭配CMS使用，Parallel Scavenge收集器搭配Parallel Old使用。此外，G1是整堆收集器，它无需搭配其他的垃圾收集器。</p><h3 id="说说Java运行时数据区"><a href="#说说Java运行时数据区" class="headerlink" title="说说Java运行时数据区"></a>说说Java运行时数据区</h3><p>解题思路</p><p>得分点 程序计数器、虚拟机栈、本地方法栈、堆、方法区 </p><p><strong>标准回答</strong> </p><p>当程序运行时,JVM需要内存来存储许多内容,例如：字节码、对象、参数、返回值、局部变量、运算的中间结果,等等,</p><p>JVM会把这些东西都存储到运行时数据区中,以便于管理。</p><p>而运行时数据区又可以分为程序计数器、虚拟机栈、本地方法栈、堆、方法区。 </p><ol><li>程序计数器 程序计数器是一块较小的内存空间,它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的概念模型里,字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令,它是程序控制流的指示器,分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。 由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的,在任何一个确定的时刻,一个处理器都只会执行一条线程中的指令。因此,为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各条线程之间计数器互不影响,独立存储,我们称这类内存区域为“线程私有”的内存。 </li><li>虚拟机栈 虚拟机栈也是线程私有的,它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候,Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程,就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 经常有人把Java内存区域笼统地划分为堆和栈,这种划分方式直接继承自传统的C、C++程序的内存布局结构,在Java语言里就显得有些粗糙了,实际的内存区域划分要比这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区域是堆和栈两块。其中,栈通常就是指这里讲的虚拟机栈,或者更多的情况下只是指虚拟机栈中局部变量表部分。 在Java虚拟机规范中,对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚拟机所允许的深度,将抛出StackOverflowError异常。如果Java虚拟机栈容量可以动态扩展,当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。 </li><li>本地方法栈 本地方法栈与虚拟机栈所发挥的作用是非常相似的,其区别只是虚拟机栈为虚拟机执行Java方法服务,而本地方法栈则是为虚拟机使用到的本地方法服务。 Java虚拟机规范对本地方法栈中方法使用的语言、使用方式与数据结构并没有任何强制规定,因此具体的虚拟机可以根据需要自由实现它,甚至有的Java虚拟机直接就把本地方法栈和虚拟机栈合二为一。 与虚拟机栈一样,本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。 </li><li>堆 堆是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域,在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例,Java世界里“几乎”所有的对象实例都在这里分配内存。堆是垃圾收集器管理的内存区域,因此一些资料中它也被称作“GC堆”。 堆既可以被实现成固定大小的,也可以是可扩展的,不过当前主流的Java虚拟机都是按照可扩展来实现的。如果在Java堆中没有内存完成实例分配,并且堆也无法再扩展时,JVM将会抛出OutOfMemoryError异常。</li><li>方法区 方法区与堆一样,是各个线程共享的内存区域,它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然Java虚拟机规范中把方法区描述为堆的一个逻辑部分,但是它却有一个别名叫作“非堆”,目的是与堆区分开来。 运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有一项信息是常量池表,用于存放编译期生成的各种字面量与符号引用。 根据Java虚拟机规范的规定,如果方法区无法满足新的内存分配需求时,将抛出OutOfMemoryError异常。</li></ol><h3 id="请你讲下CMS垃圾回收器"><a href="#请你讲下CMS垃圾回收器" class="headerlink" title="请你讲下CMS垃圾回收器"></a>请你讲下CMS垃圾回收器</h3><p>解题思路</p><p>得分点 老年代、低停顿、标记清除、四个步骤 </p><p><strong>标准回答</strong> </p><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器,从名字上就可以看出CMS收集器是基于标记清除算法实现的,它的运作过程相对于前面几种收集器来说要更复杂一些,整个过程分为四个步骤,包括：初始标记、并发标记、重新标记、并发清除。其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。 </p><ol><li>初始标记仅仅只是标记一下GC Roots能直接关联到的对象,速度很快。</li><li>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程,这个过程耗时较长但是不需要停顿用户线程,可以与垃圾收集线程一起并发运行。</li><li>重新标记阶段则是为了修正并发标记期间,因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录,这个阶段的停顿时间通常会比初始标记阶段稍长一些,但也远比并发标记阶段的时间短。</li><li>并发清除阶段,清理删除掉标记阶段判断的已经死亡的对象,由于不需要移动存活对象,所以这个阶段也是可以与用户线程同时并发的。 加分回答 CMS是一款优秀的收集器,它最主要的优点在名字上已经体现出来：并发收集、低停顿,一些官方公开文档里面也称之为“并发低停顿收集器”。CMS收集器是HotSpot虚拟机追求低停顿的第一次成功尝试,但是它还远达不到完美的程度,至少有以下三个明显的缺点：</li><li>并发阶段,它虽然不会导致用户线程停顿,却因为占用一部分线程而导致应用程序变慢,降低总吞吐量。</li><li>它无法处理“浮动垃圾”,有可能会出现“并发失败”进而导致另一次Full GC的发生。</li><li>它是一款基于标记清除算法实现的收集器,这意味着收集结束时会有大量空间碎片产生。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>I/O</title>
      <link href="/2023/01/27/IO%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/IO%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="epoll原理"><a href="#epoll原理" class="headerlink" title="epoll原理"></a>epoll原理</h3><p>解题思路</p><p>得分点 epoll_create、epoll_ctrl、epoll_wt、红黑树、双向链表、epoll的两种工作模式 </p><p><strong>标准回答</strong> </p><p>epoll 是一种更加高效的 IO 复用技术,epoll 的使用步骤及原理如下： </p><ol><li>调用 epoll_create() 会在内核中创建一个 eventpoll 结构体数据,称之为 epoll 对象,在这个结构体中有 2 个比较重要的数据成员,一个是需要检测的文件描述符的信息 struct_root rbr（红黑树）,还有一个是就绪列表struct list_head rdlist,存放检测到数据发送改变的文件描述符信息（双向链表）； </li><li>调用 epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件； </li><li>调用 epoll_wt() 可以让内核去检测就绪的事件,并将就绪的事件放到就绪列表中并返回,通过返回的事件数组做进一步的事件处理。</li></ol><p>epoll 的两种工作模式： </p><ol><li>LT 模式（水平触发） LT（Level - Triggered）是缺省的工作方式,并且同时支持 Block 和 Nonblock Socket。在这种做法中,内核检测到一个文件描述符就绪了,然后可以对这个就绪的 fd 进行 IO 操作,如果不作任何操作,内核还是会继续通知。</li><li><ol start="2"><li>ET 模式（边沿触发） ET（Edge - Triggered）是高速工作方式,只支持 Nonblock socket。在这种模式下,当描述符从未就绪变为就绪时,内核通过 epoll 检测到。然后它会假设你知道文件描述符已经就绪,并且不会再为那个文件描述符发送更多的就绪通知,直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意,如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪）,内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数,因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候,必须使用非阻塞套接口,以避免由于一个文件描述符的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li></ol></li></ol><h3 id="请你说说IO多路复用"><a href="#请你说说IO多路复用" class="headerlink" title="请你说说IO多路复用"></a>请你说说IO多路复用</h3><p>解题思路</p><p>得分点 特点（单线程可以处理多个客户端请求）、优势（系统开销小） </p><p><strong>标准回答</strong> </p><p>在I&#x2F;O编程过程中,当需要同时处理多个客户端接入请求时,可以利用多线程或者I&#x2F;O多路复用技术进行处理。I&#x2F;O多路复用技术通过把多个I&#x2F;O的阻塞复用到同一个select的阻塞上,从而使得系统在单线程的情况下可以同时处理多个客户端请求。与传统的多线程&#x2F;多进程模型比,I&#x2F;O多路复用的最大优势是系统开销小,系统不需要创建新的额外进程或者线程,也不需要维护这些进程和线程的运行,降低了系统的维护工作量,节省了系统资源。 目前支持I&#x2F;O多路复用的系统调用有select、pselect、poll、epoll,在Linux网络编程过程中,很长一段时间都使用select做轮询和网络事件通知,然而select的一些固有缺陷导致了它的应用受到了很大的限制,最终Linux不得不在新的内核版本中寻找select的替代方案,最终选择了epoll。 </p><p><strong>加分回答</strong> </p><p>epoll与select的原理比较类似,为了克服select的缺点,epoll作了很多重大改进： 1. 支持一个进程打开的socket描述符（FD）不受限制 select最大的缺陷就是单个进程所打开的FD是有一定限制的,它由FD_SETSIZE设置,默认值是1024。对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。可以选择修改这个宏然后重新编译内核,不过这会带来网络效率的下降。我们也可以通过选择多进程的方案（传统的Apache方案）解决这个问题,不过虽然在Linux上创建进程的代价比较小,但仍旧是不可忽视的,另外,进程间的数据交换非常麻烦,对于Java由于没有共享内存,需要通过Socket通信或者其他方式进行数据同步,这带来了额外的性能损耗,增加了程序复杂度,所以也不是一种完美的解决方案。值得庆幸的是,epoll并没有这个限制,它所支持的FD上限是操作系统的最大文件句柄数,这个数字远远大于1024。例如,在1GB内存的机器上大约是10万个句柄左右,具体的值可以通过cat &#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file- max察看,通常情况下这个值跟系统的内存关系比较大。 2. I&#x2F;O效率不会随着FD数目的增加而线性下降 传统的select&#x2F;poll另一个致命弱点就是当你拥有一个很大的socket集合,由于网络延时或者链路空闲,任一时刻只有少部分的socket是“活跃”的,但是select&#x2F;poll每次调用都会线性扫描全部的集合,导致效率呈现线性下降。epoll不存在这个问题,它只会对“活跃”的socket进行操作-这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的,那么,只有“活跃”的socket才会主动的去调用callback函数,其他idle状态socket则不会。在这点上,epoll实现了一个伪O。针对epoll和select性能对比的benchmark测试表明：如果所有的socket都处于活跃态-例如一个高速LAN环境,epoll并不比select&#x2F;poll效率高太多；相反,如果过多使用epoll_ctl,效率相比还有稍微的下降。但是一旦使用idle connections模拟WAN环境,epoll的效率就远在select&#x2F;poll之上了。 3. 使用mmap加速内核与用户空间的消息传递 无论是select,poll还是epoll都需要内核把FD消息通知给用户空间,如何避免不必要的内存复制就显得非常重要,epoll是通过内核和用户空间mmap同一块内存实现。 4. epoll的API更加简单 包括创建一个epoll描述符、添加监听事件、阻塞等待所监听的事件发生,关闭epoll描述符等。</p><h3 id="请你说说BIO、NIO、O"><a href="#请你说说BIO、NIO、O" class="headerlink" title="请你说说BIO、NIO、O"></a>请你说说BIO、NIO、O</h3><p>解题思路</p><p>得分点 阻塞IO模型、非阻塞IO模型、异步IO模型 标准回答 根据UNIX网络编程对I&#x2F;O模型的分类,UNIX提供了5种I&#x2F;O模型,分别是阻塞I&#x2F;O模型、非阻塞I&#x2F;O模型、I&#x2F;O复用模型、信号驱动I&#x2F;O模型、异步I&#x2F;O模型。BIO、NIO、O这五种模型中的三种,它们分别是阻塞I&#x2F;O模型、非阻塞I&#x2F;O模型、异步I&#x2F;O模型的缩写。 阻塞I&#x2F;O模型（blocking I&#x2F;O）：是最常用的I&#x2F;O模型,缺省情形下,所有文件操作都是阻塞的。我们以套接字接口为例来理解此模型,即在进程空间中调用recvfrom,其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回,在此期间一直会等待,进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的,因此被称为阻塞I&#x2F;O模型。 非阻塞I&#x2F;O模型（nonblocking I&#x2F;O）：recvfrom从应用层到内核的时候,如果该缓冲区没有数据的话,就直接返回一个EWOULDBLOCK错误,一般都对非阻塞I&#x2F;O模型进行轮询检查这个状态,看内核是不是有数据到来。 异步I&#x2F;O模型（asynchronous I&#x2F;O）：告知内核启动某个操作,并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I&#x2F;O由内核通知我们何时可以开始一个I&#x2F;O操作,异步I&#x2F;O模型由内核通知我们I&#x2F;O操作何时已经完成。 加分回答 I&#x2F;O复用模型（I&#x2F;O multiplexing）：Linux提供select&#x2F;poll,进程通过将一个或多个fd传递给select或poll系统调用,阻塞在select操作上,这样select&#x2F;poll可以帮我们侦测多个fd是否处于就绪状态。select&#x2F;poll是顺序扫描fd是否就绪,而且支持的fd数量有限,因此它的使用受到了一些制约。Linux还提供了一个epoll系统调用,epoll使用基于事件驱动方式代替顺序扫描,因此性能更高。当有fd就绪时,立即回调函数rollback。 信号驱动I&#x2F;O模型（signal-driven I&#x2F;O）：首先开启套接口信号驱动I&#x2F;O功能,并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回,进程继续工作,它是非阻塞的）。当数据准备就绪时,就为该进程生成一个SIGIO信号,通过信号回调通知应用程序调用recvfrom来读取数据,并通知主循环函数处理数据。</p><h3 id="请你说说IO多路复用（select、poll、epoll）"><a href="#请你说说IO多路复用（select、poll、epoll）" class="headerlink" title="请你说说IO多路复用（select、poll、epoll）"></a>请你说说IO多路复用（select、poll、epoll）</h3><p>解题思路</p><p>得分点 概念、select、poll、epoll </p><p>标准回答</p><p> I&#x2F;O 多路复用是一种使得程序能同时监听多个文件描述符的技术,从而提高程序的性能。</p><p>I&#x2F;O 多路复用能够在单个线程中,通过监视多个 I&#x2F;O 流的状态来同时管理多个 I&#x2F;O 流,一旦检测到某个文件描述符上我们关心的事件发生（就绪）,能够通知程序进行相应的处理（读写操作）。</p><p> Linux 下实现 I&#x2F;O 复用的系统调用主要有 select、poll 和 epoll。</p><ol><li>select <ol><li>select 的主旨思想：</li><li>首先要构造一个关于文件描述符的列表,将要监听的文件描述符添加到该列表中,这个文件描述符的列表数据类型为 fd_set,它是一个整型数组,总共是 1024 个比特位,每一个比特位代表一个文件描述符的状态。比如当需要 select 检测时,这一位为 0 就表示不检测对应的文件描述符的事件,为 1 表示检测对应的文件描述符的事件。</li><li>调用 select() 系统调用,监听该列表中的文件描述符的事件,这个函数是阻塞的,直到这些描述符中的一个或者多个进行 I&#x2F;O 操作时,该函数才返回,并修改文件描述符的列表中对应的值,0 表示没有检测到该事件,1 表示检测到该事件。函数对文件描述符的检测的操作是由内核完成的。</li><li>select() 返回时,会告诉进程有多少描述符要进行 I&#x2F;O 操作,接下来遍历文件描述符的列表进行 I&#x2F;O 操作。 </li><li>select 的缺点： <ol><li>每次调用select,都需要把 fd 集合从用户态拷贝到内核态,这个开销在 fd 很多时会很大； </li><li>同时每次调用 select 都需要在内核遍历传递进来的所有 fd,这个开销在 fd 很多时也很大；</li><li>select 支持的文件描述符数量太小了,默认是 1024（由 fd_set 决定）；</li><li>文件描述符集合不能重用,因为内核每次检测到事件都会修改,所以每次都需要重置；</li><li>每次 select 返回后,只能知道有几个 fd 发生了事件,但是具体哪几个还需要遍历文件描述符集合进一步判断。</li></ol></li></ol></li><li>poll <ol><li>poll 的原理和 select 类似,poll 支持的文件描述符没有限制。</li></ol></li><li>epoll <ol><li>epoll 是一种更加高效的 IO 复用技术,epoll 的使用步骤及原理如下： </li><li>调用 epoll_create() 会在内核中创建一个 eventpoll 结构体数据,称之为 epoll 对象,在这个结构体中有 2 个比较重要的数据成员,一个是需要检测的文件描述符的信息 struct_root rbr（红黑树）,还有一个是就绪列表struct list_head rdlist,存放检测到数据发送改变的文件描述符信息（双向链表）； </li><li>调用 epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件；</li><li>调用 epoll_wt() 可以让内核去检测就绪的事件,并将就绪的事件放到就绪列表中并返回,通过返回的事件数组做进一步的事件处理。 <ul><li>epoll 的两种工作模式： <ul><li>LT 模式（水平触发） LT（Level - Triggered）是缺省的工作方式,并且同时支持 Block 和 Nonblock Socket。在这种做法中,内核检测到一个文件描述符就绪了,然后可以对这个就绪的 fd 进行 IO 操作,如果不作任何操作,内核还是会继续通知。</li><li>ET 模式（边沿触发） ET（Edge - Triggered）是高速工作方式,只支持 Nonblock socket。在这种模式下,当描述符从未就绪变为就绪时,内核通过 epoll 检测到。然后它会假设你知道文件描述符已经就绪,并且不会再为那个文件描述符发送更多的就绪通知,直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意,如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪）,内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数,因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候,必须使用非阻塞套接口,以避免由于一个文件描述符的阻塞读&#x2F;阻塞写操作把处理多个文件描述符的任务饿死。</li></ul></li></ul></li></ol></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>应知应会</title>
      <link href="/2023/01/27/%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/%E5%BA%94%E7%9F%A5%E5%BA%94%E4%BC%9A%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="String、StringBuffer、Stringbuilder有什么区别"><a href="#String、StringBuffer、Stringbuilder有什么区别" class="headerlink" title="String、StringBuffer、Stringbuilder有什么区别"></a>String、StringBuffer、Stringbuilder有什么区别</h3><p>解题思路</p><p>得分点 字符串是否可变,StringBuffer、StringBuilder线程安全问题 </p><p><strong>标准回答</strong> </p><p>Java中提供了String,StringBuffer两个类来封装字符串,并且提供了一系列方法来操作字符串对象。 </p><p>String是一个不可变类,也就是说,一个String对象创建之后,直到这个对象销毁为止,对象中的字符序列都不能被改变。 StringBuffer对象则代表一个字符序列可变的字符串,当一个StringBuffer对象被创建之后,我们可以通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()、等方法来改变这个字符串对象的字符序列。当通过StringBuffer得到期待中字符序列的字符串时,就可以通过toString()方法将其转换为String对象。 </p><p>StringBuilder类是JDK1.5中新增的类,他也代表了字符串对象。和StringBuffer类相比,它们有共同的父类<code>AbstractStringBuilder</code>,二者无论是构造器还是方法都基本相同,不同的一点是,StringBuilder没有考虑线程安全问题,也正因如此,StringBuilder比StringBuffer性能略高。</p><p>因此,如果是在单线程下操作大量数据,应优先使用StringBuilder类；如果是在多线程下操作大量数据,应优先使用StringBuilder类。</p><h3 id="请你说说-x3D-x3D-与equals-的区别"><a href="#请你说说-x3D-x3D-与equals-的区别" class="headerlink" title="请你说说&#x3D;&#x3D;与equals()的区别"></a>请你说说&#x3D;&#x3D;与equals()的区别</h3><p>解题思路</p><p>得分点 &#x3D;&#x3D;和equals()比较基本变量用法,&#x3D;&#x3D;和equals()对比引用变量的用法 </p><p><strong>标准回答</strong> </p><p>&#x3D;&#x3D;和EQUALS都是JAVA中判断两个变量是否相等的方式,如果判断的是两个基本类型的变量,并且两者都是数值类型(不一定要求数据类型完全相同),只要两个变量的值相等就会返回TRUE。</p><p>对于两个引用变量只有他们指向同一个引用时,&#x3D;&#x3D;才会返回TRUE。&#x3D;&#x3D;不能用于比较类型上没有父子关系的两个对象。 EQUALS()方法是OBJECT类提供的一个实例方法,所以所有的引用变量都能调用EQUALS()方法来判断他是否与其他引用变量相等,但使用这个方法来判断两个引用对象是否相等的判断标准与使用&#x3D;&#x3D;运算符没有区别,它同样要求两个引用变量指向同一个对象才会返回TRUE,但如果这样的话EQUALS()方法就没有了存在的意义,所以如果我们希望自定义判断相等的标准时,可以通过重写EQUALS方法来实现。重写EQUALS()方法时,相等条件是由业务要求决定的,因此EQUALS()方法的实现是由业务要求决定的。</p><h3 id="说说static修饰符的用法"><a href="#说说static修饰符的用法" class="headerlink" title="说说static修饰符的用法"></a>说说static修饰符的用法</h3><p>解题思路</p><p>得分点 static可以修饰什么,static的重要规则 </p><p><strong>标准答案</strong> </p><p>Java类中包含了成员变量、方法、构造器、初始化块和内部类（包括接口、枚举）5种成员,</p><p>static关键字可以修饰除了构造器外的其他4种成员。</p><p>static关键字修饰的成员被称为类成员。类成员属于整个类,不属于单个对象。</p><p> static关键字有一条非常重要的规则,即类成员不能访问实例成员,因为类成员属于类的,类成员的作用域比实例成员的作用域更大,很容易出现类成员初始化完成时,但实例成员还没被初始化,这时如果类成员访问实力成员就会引起大量错误。 </p><p><strong>加分回答</strong> </p><p>static修饰的部分会和类同时被加载。被static修饰的成员先于对象存在,因此,当一个类加载完毕,即使没有创建对象也可以去访问被static修饰的部分。 静态方法中没有this关键词,因为静态方法是和类同时被加载的,而this是随着对象的创建存在的。静态比对象优先存在。也就是说,静态可以访问静态,但静态不能访问非静态而非静态可以访问静态。</p><h3 id="请你说一下final关键字"><a href="#请你说一下final关键字" class="headerlink" title="请你说一下final关键字"></a>请你说一下final关键字</h3><p>解题思路</p><p>得分点 final类,final方法,final变量 </p><p><strong>标准答案</strong></p><p> final关键字可以用来标志其修饰的类,方法和变量不可变。 </p><p>当final修饰类时,该类不能被继承,例如java.lang.Math类就是一个final类,它不能被继承。 </p><p>final修饰的方法不能被重写,如果出于某些原因你不希望子类重写父类的某个方法,就可以用final关键字修饰这个方法。 </p><p>当final用来修饰变量时,代表该变量不可被改变,一旦获得了初始值,该final变量的值就不能被重新赋值。</p><p> final既可以修饰成员变量（包括类变量和实例变量）,也可以修饰局部变量、形参。 </p><p><strong>加分回答</strong> </p><p>对于final修饰的成员变量而言,一旦有了初始值就不能被重新赋值,如果既没有在定义成员变量时指定初始值,也没有在初始化块,构造器中为成员变量指定初始值,那么这个成员变量的值将一直是系统默认分配的0、’\u0000’、false或者是null,那么这个成员变量就失去了存在的意义,所以Java语法规定：final修饰的成员变量必须由程序员显示的指定初始值。 final修饰的实例变量,要么在定义该实例变量时指定初始值,要么在普通初始化块或构造器中为该实例变量指定初始值。但要注意的是,如果普通初始化块已经为某个实例变量指定了初始值,则不能再在构造器中为该实例变量指定初始值；final修饰的类变量,要么在定义该变量时指定初始值,要么在静态初始化块中为该类变量指定初始值。 实例变量不能在静态初始化块中指定初始值,因为静态初始化块是静态成员,不可以访问实例变量；类变量不能在普通初始化块中指定初始值,因为类变量在类初始化阶段已经被初始化了,普通的初始化块不能为其重新赋值。 系统不会为局部变量进行初始化,所以局部变量必须由程序员显示的初始化。因此使用final修饰局部变量时,既可以在定义时指定默认值,也可以不指定默认值。如果final修饰的局部变量在定义是没有指定默认值,则可以在后面的代码中对该final变量赋初始值,但只能一次,不能重复赋值；如果final修饰的局部变量在定义时已经指定默认值,则后面代码中不能再对该变量赋值。</p><h3 id="请你说说泛型、泛型擦除"><a href="#请你说说泛型、泛型擦除" class="headerlink" title="请你说说泛型、泛型擦除"></a>请你说说泛型、泛型擦除</h3><p>解题思路</p><p>得分点 使用泛型的原因,泛型的概念 </p><p><strong>标准回答</strong> </p><p>Java在1.5版本中引入了泛型,在没有泛型之前,每次从集合中读取对象都必须进行类型转换,而这么做带来的结果就是：如果有人不小心插入了类型错误的对象,那么在运行时转换处理阶段就会出错。在提出泛型之后,我们可以告诉编译器集合中接受哪些对象类型。编译器会自动的为你的插入进行转化,并在编译时告知是否插入了类型错误的对象。这使程序变得更加安全更加清楚 </p><p><strong>加分回答</strong> </p><p>向上转型 在Java标准库中的<code>ArrayList&lt;t&gt;</code>实现了<code>List&lt;t&gt;</code>接口,它可以向上转型为<code>List&lt;t&gt;</code>： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayList</span>&lt;t&gt; <span class="keyword">implements</span> <span class="title class_">List</span>&lt;t&gt; &#123; ... &#125; </span><br><span class="line">List&lt;string&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;string&gt;(); </span><br></pre></td></tr></table></figure><p>即类型<code>ArrayList&lt;t&gt;</code>可以向上转型为<code>List&lt;t&gt;</code>。 </p><p>要特别注意：不能把<code>ArrayList&lt;integer&gt;</code>向上转型为<code>ArrayList&lt;number&gt;</code>或<code>List&lt;number&gt;</code>。 </p><p>这是为什么呢？假设<code>ArrayList&lt;integer&gt;</code>可以向上转型为<code>ArrayList&lt;number&gt;</code>,观察一下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 创建ArrayList&lt;integer&gt;类型： </span></span><br><span class="line">ArrayList&lt;integer&gt; integerList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;integer&gt;(); </span><br><span class="line"><span class="comment">// 添加一个Integer： </span></span><br><span class="line">integerList.add(<span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">123</span>)); </span><br><span class="line"><span class="comment">// “向上转型”为ArrayList&lt;number&gt;： </span></span><br><span class="line">ArrayList&lt;number&gt; numberList = integerList; </span><br><span class="line"><span class="comment">// 添加一个Float,因为Float也是Number： </span></span><br><span class="line">numberList.add(<span class="keyword">new</span> <span class="title class_">Float</span>(<span class="number">12.34</span>)); </span><br><span class="line"><span class="comment">// 从ArrayList&lt;integer&gt;获取索引为1的元素（即添加的Float）： </span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">n</span> <span class="operator">=</span> integerList.get(<span class="number">1</span>); </span><br><span class="line"><span class="comment">// ClassCastException! </span></span><br></pre></td></tr></table></figure><p>我们把一个<code>ArrayList&lt;integer&gt;</code>转型为<code>ArrayList&lt;number&gt;</code>类型后,这个<code>ArrayList&lt;number&gt;</code>就可以接受<code>Float</code>类型,因为<code>Float</code>是<code>Number</code>的子类。但是,<code>ArrayList&lt;number&gt;</code>实际上和<code>ArrayList&lt;integer&gt;</code>是同一个对象,也就是<code>ArrayList&lt;integer&gt;</code>类型,它不可能接受<code>Float</code>类型, 所以在获取<code>Integer</code>的时候将产生<code>ClassCastException</code>。 实际上,编译器为了避免这种错误,根本就不允许把<code>ArrayList&lt;integer&gt;</code>转型为<code>ArrayList&lt;number&gt;</code>。</p><h3 id="介绍一下MyBatis的缓存机制"><a href="#介绍一下MyBatis的缓存机制" class="headerlink" title="介绍一下MyBatis的缓存机制"></a>介绍一下MyBatis的缓存机制</h3><p>解题思路</p><p>得分点 一、二级缓存概念, </p><p><strong>标准回答</strong> </p><p>一级缓存也称为本地缓存,它默认启用且不能关闭。一级缓存存在于于SqlSession的生命周期中,即它是SqlSession级别的缓存。在同一个 SqlSession 中查询时,MyBatis 会把执行的方法和参数通过算法生成缓存的键值,将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致,那么通过算法会生成相同的键值,当Map缓存对象中己经存在该键值时,则会返回缓存中的对象。 二级缓存存在于SqlSessionFactory 的生命周期中,即它是SqlSessionFactory级别的缓存。若想使用二级缓存,需要在如下两处进行配置：</p><ul><li>在MyBatis 的全局配置settings 中有一个参数cacheEnabled,这个参数是二级缓存的全局开关,默认值是true ,初始状态为启用状态。 </li><li>MyBatis 的二级缓存是和命名空间绑定的,即二级缓存需要配置在Mapper.xml 映射文件中。在保证二级缓存的全局配置开启的情况下,给Mapper.xml 开启二级缓存需要在Mapper. xml 中添加如下代码: 二级缓存具有如下效果： - 映射语句文件中的所有SELECT 语句将会被缓存。</li><li>映射语句文件中的所有时INSERT 、UPDATE 、DELETE 语句会刷新缓存。 - 缓存会使用Least Recently U sed ( LRU ,最近最少使用的）算法来收回。 </li><li>根据时间表（如no Flush Interval ,没有刷新间隔）,缓存不会以任何时间顺序来刷新。 - 缓存会存储集合或对象（无论查询方法返回什么类型的值）的1024 个引用。</li><li>缓存会被视为read&#x2F;write（可读／可写）的,意味着对象检索不是共享的,而且可以安全地被调用者修改,而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>加分回答 Mybatis 一级缓存失效的四种情况： </p><ul><li>sqlsession变了 缓存失效</li><li>sqlsession不变,查询条件不同,一级缓存失效 </li><li>sqlsession不变,中间发生了增删改操作,一级缓存失败 </li><li>sqlsession不变,手动清除缓存,一级缓存失败</li></ul><p>MyBatis的二级缓存相对于一级缓存来说,实现了SqlSession之间缓存数据的共享,同时粒度更加的细,能够到namespace级别,通过Cache接口实现类不同的组合,对Cache的可控性也更强。 MyBatis在多表查询时,极大可能会出现脏数据,这导致安全使用二级缓存的条件比较苛刻。 由于默认的MyBatis Cache实现都是基于本地的,这导致在分布式环境下,一定会出现读取到脏数据的情况,且开发成本较高,所以开发环境中一般都会直接使用Redis,Memcached等分布式缓存.</p><p>###请你说说String类,以及new和</p><p>解题思路</p><p>得分点 String常用方法简单介绍,String能否被继承,创建字符串的两种方式 </p><p>标准回答 </p><p>String类是Java最常用的API,它包含了大量处理字符串的方法,比较常用的有： </p><ul><li>char charAt(int index)：返回指定索引处的字符； </li><li>String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li><li>String[] split(String regex)：以指定的规则将此字符串分割成数组； </li><li>String trim()：删除字符串前导和后置的空格； </li><li>int indexOf(String str)：返回子串在此字符串首次出现的索引； </li><li>int lastIndexOf(String str)：返回子串在此字符串最后出现的索引； </li><li>boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头； </li><li>boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾； </li><li>String toUpperCase()：将此字符串中所有的字符大写； </li><li>String toLowerCase()：将此字符串中所有的字符小写； </li><li>String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串； </li><li>String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li></ul><p>String类是由final修饰的,所以他不能被继承。 </p><p>创建字符串有两种方式,一种是使用字符串直接量,另一种是使用new关键字,当使用字符串直接量的方式来创建字符串时,JVM会使用常量池来管理这个字符串,当使用new关键字来创建字符串时,JVM会先使用常量池来管理字符串直接量,再调用String类的构造器来创建一个新的String对象,新创建的String对象会被保存在堆内存中。对比来说,采用new的方式会多创建出一个对象来,占用了更多的内存 ,所以建议采用直接量的方式来创建字符串。</p><p>###说说你对线程池的理解</p><p>解题思路</p><p>得分点 核心参数、处理流程、拒绝策略 </p><p><strong>标准回答</strong> </p><p>线程池可以有效地管理线程：</p><p>它可以管理线程的数量,可以避免无节制的创建线程,导致超出系统负荷直至崩溃。它还可以让线程复用,可以大大地减少创建和销毁线程所带来的开销。 </p><p>线程池需要依赖一些参数来控制任务的执行流程,其中最重要的参数有：corePoolSize（核心线程数）、workQueue（等待队列）、maxinumPoolSize（最大线程数）、handler（拒绝策略）、keepAliveTime（空闲线程存活时间）。</p><p>当我们向线程池提交一个任务之后,线程池按照如下步骤处理这个任务： </p><ol><li>判断线程数是否达到corePoolSize,若没有则新建线程执行该任务,否则进入下一步。</li><li>判断等待队列是否已满,若没有则将任务放入等待队列,否则进入下一步。 </li><li>判断线程数是否达到maxinumPoolSize,如果没有则新建线程执行任务,否则进入下一步。 </li><li>采用初始化线程池时指定的拒绝策略,拒绝执行该任务。 </li><li>新建的线程处理完当前任务后,不会立刻关闭,而是继续处理等待队列中的任务。如果线程的空闲时间达到了keepAliveTime,则线程池会销毁一部分线程,将线程数量收缩至corePoolSize。</li></ol><p>第2步中的队列可以有界也可以无界。若指定了无界的队列,则线程池永远无法进入第3步,相当于废弃了maxinumPoolSize参数。</p><p>这种用法是十分危险的,如果任务在队列中产生大量的堆积,就很容易造成内存溢出。</p><p>JDK为我们提供了一个名为Executors的线程池的创建工具,该工具创建出来的就是带有无界队列的线程池,所以一般在工作中我们是不建议使用这个类来创建线程池的。 </p><p>第4步中的拒绝策略主要有4个：</p><p>让调用者自己执行任务、直接抛出异常、丢弃任务不做任何处理、删除队列中最老的任务并把当前任务加入队列。</p><p>这4个拒绝策略分别对应着RejectedExecutionHandler接口的4个实现类,我们也可以基于这个接口实现自己的拒绝策略。 在Java中,线程池的实际类型为ThreadPoolExecutor,它提供了线程池的常规用法。该类还有一个子类,名为ScheduledThreadPoolExecutor,它对定时任务提供了支持。在子类中,我们可以周期性地重复执行某个任务,也可以延迟若干时间再执行某个任务。 </p><p><strong>加分回答</strong> </p><p>线程池的生命周期包含5个状态：RUNNING、SHUTDOWN、STOP、TIDING、TERMINATED。</p><p>这5种状态的状态值分别是：-1、0、1、2、3。在线程池的生命周期中,它的状态只能由小到大迁移,是不可逆的。 </p><ol><li>RUNNING：表示线程池正在运行。</li><li>SHUTDOWN：执行shutdown()时进入该状态,此时队列不会清空,线程池会等待任务执行完毕。 </li><li>STOP：执行shutdownNow()时进入该状态,此时现线程池会清空队列,不再等待任务的执行。 </li><li>TIDING：当线程池及队列为空时进入该状态,此时线程池会执行钩子函数,目前该函数是一个空的实现。 </li><li>TERMINATED：钩子函数执行完毕后,线程进入该状态,表示线程池已经死亡。</li></ol><h3 id="请你说说Java的异常处理机制"><a href="#请你说说Java的异常处理机制" class="headerlink" title="请你说说Java的异常处理机制"></a>请你说说Java的异常处理机制</h3><p>解题思路</p><p>得分点 异常处理、抛出异常、异常跟踪栈 </p><p><strong>标准回答</strong> </p><p>异常处理机制可以让程序具有极好的容错性和健壮性,当程序运行出现了意料之外的状况时,系统会生成一个Exception对象来通知程序,从而实现“业务功能实现部分代码”与“错误处理部分代码”分离,使程序获得更好的可读性。 </p><p>Java的异常机制可以分成异常处理、抛出异常和异常跟踪栈问题三个部分。 </p><p>处理异常的语句由try、catch、finally三部分组成。try块用于包裹业务代码,catch块用于捕获并处理某个类型的异常,finally块则用于回收资源。</p><p>如果业务代码发生异常,系统就会创建一个异常对象,并将这个异常对象提交给JVM,然后由JVM寻找可以处理这个异常的catch块,并将异常对象交给这个catch块处理。</p><p>如果JVM没有找到可以处理异常的catch代码块,那么运行环境会终止,Java程序也会退出。若业务代码打开了某项资源,则可以在finally块中关闭这项资源,因为无论是否发生异常,finally块一定会执行（一般情况下）。</p><p> 当程序出现错误时,系统会自动抛出异常。</p><p>除此以外,Java也允许程序主动抛出异常。</p><p>当业务代码中,判断某项错误的条件成立时,可以使用throw关键字向外抛出异常。</p><p>在这种情况下,如果当前方法不知道该如何处理这个异常,可以在方法签名上通过throws关键字声明抛出异常,则该异常将交给JVM处理。 程序运行时,经常会发生一系列方法调用,从而形成方法调用栈。</p><p>异常机制会导致异常在这些方法之间传播,而异常传播的顺序与方法的调用相反。</p><p>异常从发生异常的方法向外传播,首先传给该方法的调用者,再传给上层调用者,以此类推。最终会传到mn方法,若依然没有得到处理,则JVM会终止程序,并打印异常跟踪栈的信息。 </p><p><strong>加分回答</strong> </p><p>throw、throws区别</p><p> throws： </p><ul><li>只能在方法签名中使用 </li><li>可以声明抛出多个异常,多个一场之间用逗号隔开 </li><li>表示当前方法不知道如何处理这个异常,这个异常由该方法的调用者处理（如果mn方法也不知该怎么处理异常,这个异常就会交给JVM处理,JVM处理异常的方式是,打印异常跟踪栈信息并终止程序运行,这也就是为什么程序遇到异常会自动结束的的原因） </li><li>throws表示出现异常的一种可能性,并不一定会发生这些异常</li></ul><p>throw： </p><ul><li>表示方法内抛出某种异常对象,throw语句可以单独使用。 </li><li>throw语句抛出的是一个异常实例,不是一个异常类,而且每次只能抛出一个异常实例 </li><li>执行throw一定抛出了某种异常 关于finally的问题 当Java程序执行try块、catch块时遇到了return或throw语句,这两个语句都会导致该方法立即结束,但是系统执行这两个语句并不会结束该方法,而是去寻找该异常处理流程中是否包含finally块,如果没有finally块,程序立即执行return或throw语句,方法终止；如果有finally块,系统立即开始执行finally块。只有当finally块执行完成后,系统才会再次跳回来执行try块、catch块里的return或throw语句；如果finally块里也使用了return或throw等语句,finally块会终止方法,系统将不会跳回去执行try块、catch块里的任何代码。这将会导致try块、catch块中的return、throw语句失效,所以,我们应该尽量避免在finally块中使用return或throw。 </li><li>finally代码块不执行的几种情况：</li><li>如果当一个线程在执行 try 语句块或者catch语句块时被打断interrupted或者被终止killed,与其相对应的 finally 语句块可能不会执行。 </li><li>如果在try块或catch块中使用 <code>System.exit(1);</code> 来退出虚拟机,则finally块将失去执行的机会。</li></ul><h3 id="请介绍一下访问修饰符"><a href="#请介绍一下访问修饰符" class="headerlink" title="请介绍一下访问修饰符"></a>请介绍一下访问修饰符</h3><p>解题思路</p><p>得分点 private、default、protected、public </p><p><strong>标准回答</strong> </p><p>Java除了提供的三个访问修饰符分别代表三个访问级别之外还有一个不加修饰符的访问级别,</p><p>它们访问级别控制从小到大为： private-&gt;default-&gt;protected-&gt;public 他们访问级别分别如下： </p><p>private：类中被private修饰的成员只能在当前类的内部被访问。根据这点,我们可以使用它来修饰成员变量,从而将成员变量隐藏在这个类的内部。 </p><p>default：如果类中的成员或者一个外部类不使用任何访问修饰符来进行修饰,那么他就是default级别的,default访问控制的类成员或者外部类可以被相同包下的其他类访问。 </p><p>protected：如果一个类成员被protected访问修饰符修饰,那么这个成员不但可以被同一个包下的其他类访问,还可以被其他包下的子类访问。一般来讲,如果一个方法被protected修饰,那么通常是希望它的子类来重写它。 </p><p>public：这是Java中最宽松的访问级别,如果类成员被这个修饰符修饰,那么无论访问类和被访问类在不在一个包下,有没有父子关系,这个类成员都可以被访问到。 </p><p><strong>加分回答</strong> </p><p>对于局部变量而言,它的作用域就是他所在的方法,不可能被其它类所访问,所以不能使用访问修饰符来修饰。 对于外部类而言,它只有两种控制级别：public和默认,外部类之所以不能用protected和private修饰,是因为外部类没有处于任何类的内部,所以就没有它所在类的内部,所在类的子类两个范围,protected和private没有意义。使用public声明的外部类可以被所有类引用；不使用访问修饰符创建的外部类只有同一个包内的类能引用。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式</title>
      <link href="/2023/01/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请你讲讲单例模式、请你手写一下单例模式"><a href="#请你讲讲单例模式、请你手写一下单例模式" class="headerlink" title="请你讲讲单例模式、请你手写一下单例模式"></a>请你讲讲单例模式、请你手写一下单例模式</h3><p>解题思路</p><p>得分点 饿汉式单例模式、懒汉式单例模式、线程安全的懒汉式单例模式 标准回答 </p><p>单例模式（Singleton Pattern）是最简单的创建型设计模式。它会确保一个类只有一个实例存在。单例模式最重要的特点就是构造函数私有,从而避免外界直接使用构造函数直接实例化该类的对象。 </p><p>单例模式在Java种通常有两种表现形式：</p><ul><li>饿汉式：类加载时就进行对象实例化</li><li>懒汉式：第一次引用类时才进行对象实例化</li></ul><p> 饿汉式单例模式： 在类被加载时就会初始化静态变量instance,这时候类的私有构造函数就会被调用,创建唯一的实例。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span>&#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>(); <span class="comment">// 构造方法私有,确保外界不能直接实例化 </span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123; &#125; <span class="comment">//通过公有的静态方法获取对象实例 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>懒汉式单例模式： 类在加载时不会初始化静态变量instance,而是在第一次被调用时将自己初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 私有构造方法,确保外界不能直接实例化。 </span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 通过公有的静态方法获取对象实例 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstace</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>但这时有一个问题,如果线程A和B同时调用此方法,会出现执行<code>if (instance == null)</code>语句时都为真的情况,那么线程AB都会创建一个对象,那内存中就会出现两个对象,这违反了单例模式的定义。</p><p>为解决这一问题,可以使用synchronized关键字对静态方法 getInstance()进行同步,线程安全的的懒汉式单例模式代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 私有构造方法,确保外界不能直接实例化。 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 通过公有的静态方法获取对象实例 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstace</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123; </span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> instance; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>饿汉式单例类在资源利用效率上不如懒汉式单例类,但从速度和反应时间来看,饿汉式单例类要优于懒汉式单例类。</p><p> 加分回答 </p><p>单例模式的优点： </p><ul><li>在一个对象需要频繁的销毁、创建,而销毁、创建性能又无法优化时,单例模式的优势尤其明显 - 在一个对象的产生需要比较多资源时,如读取配置、产生其他依赖对象时,则可以通过在启用时直接产生一个单例对象,然后用永久驻留内存的方式来解决 </li><li>单例模式可以避免对资源的多重占用,因为只有一个实例,避免了对一个共享资源的并发操作 - 单例模式可以在系统设置全局的访问点,优化和共享资源访问</li></ul><p>单例模式的缺点：</p><ul><li>单例模式无法创建子类,扩展困难,若要扩展,除了修改代码基本上没有第二种途径可以实现 </li><li>单例模式对测试不利。在并行开发环境中,如果采用单例模式的类没有完成,是不能进行测试的 </li><li>单例模式与单一职责原则有冲突。一个类应该只实现一个逻辑,而不关心它是否是单例的,是不是要用单例模式取决于环境</li></ul><h3 id="请你讲讲工厂模式-手写实现工厂模式"><a href="#请你讲讲工厂模式-手写实现工厂模式" class="headerlink" title="请你讲讲工厂模式,手写实现工厂模式"></a>请你讲讲工厂模式,手写实现工厂模式</h3><p>解题思路</p><p>得分点 简单工厂、工厂方法、抽象工厂 </p><p><strong>标准回答</strong> </p><p>工厂模式（Factory Method Pattern）也叫虚拟构造函数模式或多态性工厂模式,其用意是定义一个创建产品对象的工厂接口,将实际创建性工作推迟到子类中。 </p><p>工厂模式可以分为简单工厂、工厂方法和抽象工厂模式 </p><p>简单工厂模式严格来讲并不算是一种设计模式,更多的时候是一种编程习惯。简单工厂的实现思路是,定义一个工厂类,根据传入的参数不同返回不同的实例,被创建的实例具有共同的父类或接口。简单工厂适用于需要创建的对象较少或客户端不关心对象的创建过程的情况。 </p><p>示例： 创建一个可以绘制不同形状的绘图工具,可以绘制圆形,正方形,三角形,每个图形都会有一个draw()方法用于绘图,首先可以定义一个接口或者抽象类,作为这三个图像的公共父类,并在其中声明一个公共的draw方法： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Shape</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面就是编写具体的图形,每种图形都实现Shape接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 圆形 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CircleShape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CircleShape</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;CircleShape: created&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;draw: CircleShape&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 正方形 </span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RectShape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RectShape</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;RectShape: created&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;draw: RectShape&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 三角形 </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TriangleShape</span> <span class="keyword">implements</span> <span class="title class_">Shape</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TriangleShape</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;TriangleShape: created&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">draw</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;draw: TriangleShape&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面是工厂类的具体实现： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ShapeFactory</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Shape <span class="title function_">getShape</span><span class="params">(String type)</span> &#123; </span><br><span class="line">        <span class="type">Shape</span> <span class="variable">shape</span> <span class="operator">=</span> <span class="literal">null</span>; </span><br><span class="line">        <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;circle&quot;</span>)) &#123; </span><br><span class="line">            shape = <span class="keyword">new</span> <span class="title class_">CircleShape</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;rect&quot;</span>)) &#123; </span><br><span class="line">            shape = <span class="keyword">new</span> <span class="title class_">RectShape</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equalsIgnoreCase(<span class="string">&quot;triangle&quot;</span>)) &#123; </span><br><span class="line">            shape = <span class="keyword">new</span> <span class="title class_">TriangleShape</span>(); </span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> shape; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>为工厂类传入不同的type可以new不同的形状,返回结果为Shape 类型,这个就是简单工厂核心的地方了。 </p><p>工厂方法模式 工厂方法模式具有良好的封装性,代码结构清晰,一个对象创建是有条件约束的,如果一个调用者需要一个具体的产品对象,只要知道这个产品的类名或约束字符串即可,不用知道创建对象的过程如何,降低了模块间的耦合。</p><p>工厂模式还拥有优秀的可扩展性,在增加产品类的情况下,只要适当地修改具体的工厂类或扩展一个工厂类,就可以适应变化。工厂方法模式是典型的解耦框架,高层模块只需要知道产品的抽象类或接口,其他的实现类都不用关心。</p><p>举个例子,通过汽车工厂来演示工厂模式： 首先创建一个Car的接口： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123; </span><br><span class="line">    <span class="comment">//品牌 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brand</span><span class="params">()</span>; </span><br><span class="line">    <span class="comment">//速度 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span>; </span><br><span class="line">    <span class="comment">//价格 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">price</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//再创建一个Car的抽象工厂： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CarFactory</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">factory</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//奥迪Audi类实现Car接口,是一个具体的产品： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Audi</span> <span class="keyword">implements</span> <span class="title class_">Car</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brand</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;一台奥迪&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;快&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">price</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;贵&quot;</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//奥拓Auto类实现Car接口,是一个具体的产品： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Auto</span> <span class="keyword">implements</span> <span class="title class_">Car</span>&#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">brand</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;一台奥拓&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">speed</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;慢&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">price</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;便宜&quot;</span>); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//奥迪工厂AudiFactory实现CarFactory接口,专门用于生产奥迪： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AudiFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">factory</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Audi</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//奥拓工厂AutoFactory实现CarFactory接口,专门用于生产奥拓： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AutoFactory</span> <span class="keyword">implements</span> <span class="title class_">CarFactory</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> Car <span class="title function_">factory</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Auto</span>(); &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//应用场景代码： </span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientDemo</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">        CarFactory carFactory= <span class="keyword">new</span> <span class="title class_">AudiFactory</span>(); </span><br><span class="line">        <span class="type">Car</span> <span class="variable">audi</span> <span class="operator">=</span> carFactory.factory(); </span><br><span class="line">        audi.brand(); </span><br><span class="line">        audi.speed(); </span><br><span class="line">        audi.price(); </span><br><span class="line">        carFactory=<span class="keyword">new</span> <span class="title class_">AutoFactory</span>(); </span><br><span class="line">        <span class="type">Car</span> <span class="variable">auto</span> <span class="operator">=</span> carFactory.factory(); </span><br><span class="line">        auto.brand(); </span><br><span class="line">        auto.speed(); </span><br><span class="line">        auto.price(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>运行结果为： </p><p>一台奥迪 快 贵 一台奥拓 慢 便宜 </p><p>抽象工厂模式（Abstract Factory Pattern）是一种比较常用的模式。为创建一组相关或相互依赖的对象提供一个接口,而且无须指定它们的具体类。抽象工厂模式是工厂方法模式的升级版本。在有多个业务品种、业务分类时,通过抽象工厂模式产生需要的对象是一种非常好的解决方式,抽象方法适用于下和工厂方法一样客户端不需要知道它所创建的对象的类,需要一组对象共同完成某种功能,可能存在多组对象完成不同功能以及系统结构稳定,不会频繁的增加对象的情况。 </p><p>这里举个例子： 现在需要做一款跨平台的游戏,需要兼容Android,Ios,Wp三个移动操作系统,该游戏针对每个系统都设计了一套操作控制器（OperationController）和界面控制器（UIController）,下面通过抽闲工厂方式完成这款游戏的架构设计。 </p><p>由题可知,游戏里边的各个平台的UIController和OperationController应该是我们最终生产的具体产品。所以新建两个抽象产品接口。 </p><p>抽象操作控制器： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">OperationController</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">control</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>抽象界面控制器： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">UIController</span> &#123; </span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span>; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><blockquote><p>然后完成各个系统平台的具体操作控制器和界面控制器。 </p></blockquote><p>Android： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidOperationController</span> <span class="keyword">implements</span> <span class="title class_">OperationController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">control</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;AndroidOperationController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AndroidUIController</span> <span class="keyword">implements</span> <span class="title class_">UIController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;AndroidInterfaceController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>IOS： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IosOperationController</span> <span class="keyword">implements</span> <span class="title class_">OperationController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">control</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;IosOperationController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">IosUIController</span> <span class="keyword">implements</span> <span class="title class_">UIController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;IosInterfaceController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>WP： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WpOperationController</span> <span class="keyword">implements</span> <span class="title class_">OperationController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">control</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;WpOperationController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WpUIController</span> <span class="keyword">implements</span> <span class="title class_">UIController</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">()</span> &#123; </span><br><span class="line">        System.out.println(<span class="string">&quot;WpInterfaceController&quot;</span>); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>下面定义一个抽象工厂,该工厂需要可以创建OperationController和UIController。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">SystemFactory</span> &#123; </span><br><span class="line">    <span class="keyword">public</span> OperationController <span class="title function_">createOperationController</span><span class="params">()</span>; </span><br><span class="line">    <span class="keyword">public</span> UIController <span class="title function_">createInterfaceController</span><span class="params">()</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在各平台具体的工厂类中完成操作控制器和界面控制器的创建过程。 </p><p>Android： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AndroidFactory</span> <span class="keyword">implements</span> <span class="title class_">SystemFactory</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> OperationController <span class="title function_">createOperationController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndroidOperationController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> UIController <span class="title function_">createInterfaceController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AndroidUIController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>IOS：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IosFactory</span> <span class="keyword">implements</span> <span class="title class_">SystemFactory</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> OperationController <span class="title function_">createOperationController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IosOperationController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> UIController <span class="title function_">createInterfaceController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">IosUIController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>WP： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WpFactory</span> <span class="keyword">implements</span> <span class="title class_">SystemFactory</span> &#123; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> OperationController <span class="title function_">createOperationController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WpOperationController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="meta">@Override</span> </span><br><span class="line">    <span class="keyword">public</span> UIController <span class="title function_">createInterfaceController</span><span class="params">()</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">WpUIController</span>(); </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>加分回答</strong> </p><p>简单工厂模式其实并不算是一种设计模式,更多的时候是一种编程习惯。简单工厂的实现思路是,定义一个工厂类,根据传入的参数不同返回不同的实例,被创建的实例具有共同的父类或接口。 </p><p>工厂方法模式是简单工厂的仅一步深化, 在工厂方法模式中,我们不再提供一个统一的工厂类来创建所有的对象,而是针对不同的对象提供不同的工厂。也就是说每个对象都有一个与之对应的工厂。</p><p>工厂方法的实现思路是,定义一个用于创建对象的接口,让子类决定将哪一个类实例化。</p><p>工厂方法模式让一个类的实例化延迟到其子类。 </p><p>抽象工厂模式是工厂方法的进一步深化,在这个模式中的工厂类不单单可以创建一个对象,而是可以创建一组对象。这是和工厂方法最大的不同点。</p><p>抽象工厂的实现思路是,提供一个创建一系列相关或相互依赖对象的接口,而无须指定它们具体的类。</p><h3 id="说说你对MVC的理解"><a href="#说说你对MVC的理解" class="headerlink" title="说说你对MVC的理解"></a>说说你对MVC的理解</h3><p>解题思路</p><p>得分点 mvc概念,model、view、controller模块功能 标准回答 </p><p>MVC是一种设计模式,在这种模式下软件被分为三层,即Model（模型）、View（视图）、Controller（控制器）。</p><p>Model代表的是数据,View代表的是用户界面,Controller代表的是数据的处理逻辑,它是Model和View这两层的桥梁。</p><p>将软件分层的好处是,可以将对象之间的耦合度降低,便于代码的维护。</p><p> Model：指从现实世界中抽象出来的对象模型,是应用逻辑的反应；它封装了数据和对数据的操作,是实际进行数据处理的地方（模型层与数据库才有交互）。在MVC的三个部件中,模型拥有最多的处理任务。被模型返回的数据是中立的,模型与数据格式无关,这样一个模型能为多个视图提供数据,由于应用于模型的代码只需写一次就可以被多个视图重用,所以减少了代码的重复性。</p><p> View：负责进行模型的展示,一般就是我们见到的用户界面。 </p><p>Controller：控制器负责视图和模型之间的交互,控制对用户输入的响应、响应方式和流程；它主要负责两方面的动作,一是把用户的请求分发到相应的模型,二是吧模型的改变及时地反映到视图上。 </p><p>加分回答 为了解耦以及提升代码的可维护性,服务端开发一般会对代码进行分层,服务端代码一般会分为三层：表现层、业务层、数据访问层。在浏览器访问服务器时,请求会先到达表现层 最典型的MVC就是jsp+servlet+javabean模式。 以JavaBean作为模型,既可以作为数据模型来封装业务数据,又可以作为业务逻辑模型来包含应用的业务操作。 JSP作为视图层,负责提供页面为用户展示数据,提供相应的表单（Form）来用于用户的请求,并在适当的时候（点击按钮）向控制器发出请求来请求模型进行更新。 Serlvet作为控制器,用来接收用户提交的请求,然后获取请求中的数据,将之转换为业务模型需要的数据模型,然后调用业务模型相应的业务方法进行更新,同时根据业务执行结果来选择要返回的视图。 当然,这种方式现在已经不那么流行了,Spring MVC框架已经成为了MVC模式的最主流实现。</p><p> Spring MVC框架是基于Java的实现了MVC框架模式的请求驱动类型的轻量级框架。前端控制器是DispatcherServlet接口实现类,映射处理器是HandlerMapping接口实现类,视图解析器是ViewResolver接口实现类,页面控制器是Controller接口实现类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合</title>
      <link href="/2023/01/27/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/%E9%9B%86%E5%90%88%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请你说说ArrayList和LinkedList的区别"><a href="#请你说说ArrayList和LinkedList的区别" class="headerlink" title="请你说说ArrayList和LinkedList的区别"></a>请你说说ArrayList和LinkedList的区别</h3><p>解题思路</p><p>得分点 数据结构、访问效率 </p><p>标准回答 </p><ol><li>ArrayList的实现是基于数组,LinkedList的实现是基于双向链表。 </li><li>对于随机访问ArrayList要优于LinkedList,ArrayList可以根据下标以O(1)时间复杂度对元素进行随机访问,而LinkedList的每一个元素都依靠地址指针和它后一个元素连接在一起,查找某个元素的时间复杂度是O(N)。 </li><li>对于插入和删除操作,LinkedList要优于ArrayList,因为当元素被添加到LinkedList任意位置的时候,不需要像ArrayList那样重新计算大小或者是更新索引。 </li><li>LinkedList比ArrayList更占内存,因为LinkedList的节点除了存储数据,还存储了两个引用,一个指向前一个元素,一个指向后一个元素。</li></ol><blockquote><p>linkedList的头尾删除性能高</p><p>Arraylist尾部插入删除性能高</p><p>可以利用cpu缓存,局部性原理</p></blockquote><h3 id="请你说说HashMap底层原理"><a href="#请你说说HashMap底层原理" class="headerlink" title="请你说说HashMap底层原理"></a>请你说说HashMap底层原理</h3><p>解题思路</p><p>得分点 数据结构、put()流程、扩容机制 </p><p><strong>标准回答</strong> </p><p>数据结构 在JDK8中,HashMap底层是采用“数组+链表+红黑树”来实现的。 </p><p>HashMap是基于哈希算法来确定元素的位置（槽）的,当我们向集合中存入数据时,它会计算传入的Key的哈希值,并利用哈希值取余来确定槽的位置。</p><p>如果元素发生碰撞,也就是这个槽已经存在其他的元素了,则HashMap会通过链表将这些元素组织起来。</p><p>如果碰撞进一步加剧,某个链表的长度达到了8,则HashMap会创建红黑树来代替这个链表,从而提高对这个槽中数据的查找的速度。 </p><p>HashMap中,数组的默认初始容量为16,这个容量会以2的指数进行扩容。</p><p>具体来说,当数组中的元素达到一定比例的时候HashMap就会扩容,这个比例叫做负载因子,默认为0.75。</p><p>自动扩容机制,是为了保证HashMap初始时不必占据太大的内存,而在使用期间又可以实时保证有足够大的空间。</p><p>采用2的指数进行扩容,是为了利用位运算,提高扩容运算的效率。</p><p> put()流程 put()方法的执行过程中,主要包含四个步骤： </p><ol><li><p>判断数组,若发现数组为空,则进行首次扩容。 </p></li><li><p>判断头节点,若发现头节点为空,则新建链表节点,存入数组。 </p></li><li><p>判断头节点,若发现头节点非空,则将元素插入槽内。 </p><ol><li>若元素的key与头节点一致,则直接覆盖头节点。</li><li>若元素为树型节点,则将元素追加到树中。</li><li>若元素为链表节点,则将元素追加到链表中。追加后,需要判断链表长度以决定是否转为红黑树。若链表长度达到8、数组容量未达到64,则扩容。若链表长度达到8、数组容量达到64,则转为红黑树。</li></ol></li><li><p>插入元素后,判断元素的个数,若发现超过阈值则再次扩容。</p></li></ol><p>扩容机制 </p><p>向HashMap中添加数据时,有三个条件会触发它的扩容行为： </p><ol><li>如果数组为空,则进行首次扩容。 </li><li>将元素接入链表后,如果链表长度达到8,并且数组长度小于64,则扩容。 </li><li>添加后,如果数组中元素超过阈值,即比例超出限制（默认为0.75）,则扩容。 并且,每次扩容时都是将容量翻倍,即创建一个2倍大的新数组,然后再将旧数组中的数组迁移到新数组里。由于HashMap中数组的容量为2^N,所以可以用位移运算计算新容量,效率很高。</li></ol><p> <strong>加分回答</strong> </p><p>HashMap是非线程安全的,在多线程环境下,多个线程同时触发HashMap的改变时,有可能会发生冲突。所以,在多线程环境下不建议使用HashMap,可以考虑使用Collections将HashMap转为线程安全的HashMap,更为推荐的方式则是使用ConcurrentHashMap。</p><h3 id="请你说说ConcurrentHashMap"><a href="#请你说说ConcurrentHashMap" class="headerlink" title="请你说说ConcurrentHashMap"></a>请你说说ConcurrentHashMap</h3><p>解题思路</p><p>得分点 数组+链表+红黑树、锁的粒度 </p><p><strong>标准回答</strong> </p><p>在JDK8中,ConcurrentHashMap的底层数据结构与HashMap一样,也是采用“数组+链表+红黑树”的形式。同时,它又采用锁定头节点的方式降低了锁粒度,以较低的性能代价实现了线程安全。</p><p>底层数据结构的逻辑可以参考HashMap的实现,下面我重点介绍它的线程安全的实现机制。 </p><ol><li>初始化数组或头节点时,ConcurrentHashMap并没有加锁,而是CAS的方式进行原子替换（原子操作,基于Unsafe类的原子操作API）。 </li><li>插入数据时会进行加锁处理,但锁定的不是整个数组,而是槽中的头节点。所以,ConcurrentHashMap中锁的粒度是槽,而不是整个数组,并发的性能很好。 </li><li>扩容时会进行加锁处理,锁定的仍然是头节点。并且,支持多个线程同时对数组扩容,提高并发能力。每个线程需先以CAS操作抢任务,争抢一段连续槽位的数据转移权。抢到任务后,该线程会锁定槽内的头节点,然后将链表或树中的数据迁移到新的数组里。 </li><li>查找数据时并不会加锁,所以性能很好。</li><li>另外,在扩容的过程中,依然可以支持查找操作。</li><li>如果某个槽还未进行迁移,则直接可以从旧数组里找到数据。</li><li>如果某个槽已经迁移完毕,但是整个扩容还没结束,则扩容线程会创建一个转发节点存入旧数组,届时查找线程根据转发节点的提示,从新数组中找到目标数据。</li></ol><p><strong>加分回答</strong> </p><p>ConcurrentHashMap实现线程安全的难点在于多线程并发扩容,即当一个线程在插入数据时,若发现数组正在扩容,那么它就会立即参与扩容操作,完成扩容后再插入数据到新数组。</p><p>在扩容的时候,多个线程共同分担数据迁移任务,每个线程负责的迁移数量是 <code>(数组长度 &gt;&gt;&gt; 3) / CPU核心数</code>。 也就是说,为线程分配的迁移任务,是充分考虑了硬件的处理能力的。</p><p>多个线程依据硬件的处理能力,平均分摊一部分槽的迁移工作。另外,如果计算出来的迁移数量小于16,则强制将其改为16,这是考虑到目前服务器领域主流的CPU运行速度,每次处理的任务过少,对于CPU的算力也是一种浪费。</p><blockquote><p>因为数组长度不是质数所以会采用二次哈希</p><p>0.75是扩容和哈希分布的折中</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>高级算法</title>
      <link href="/2023/01/27/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="说说你对AQS的理解"><a href="#说说你对AQS的理解" class="headerlink" title="说说你对AQS的理解"></a>说说你对AQS的理解</h3><p>解题思路</p><p>得分点 模板方法、同步队列、同步状态 </p><p><strong>标准回答</strong> </p><p>AQS（AbstractQueuedSynchronizer）是队列同步器,是用来构建锁的基础框架,Lock实现类都是基于AQS实现的。AQS是基于模板方法模式进行设计的,所以锁的实现需要继承AQS并重写它指定的方法。AQS内部定义了一个FIFO的队列来实现线程的同步,同时还定义了同步状态来记录锁的信息。 AQS的模板方法,将管理同步状态的逻辑提炼出来形成标准流程,这些方法主要包括：独占式获取同步状态、独占式释放同步状态、共享式获取同步状态、共享式释放同步状态。以独占式获取同步状态为例,它的大致流程是：</p><ol><li>尝试以独占方式获取同步状态。</li><li>如果状态获取失败,则将当前线程加入同步队列。</li><li>自旋处理同步状态,如果当前线程位于队头,则唤醒它并让它出队,否则使其进入阻塞状态。 其中,有些步骤无法在父类确定,则提炼成空方法留待子类实现。例如,第一步的尝试操作,对于公平锁和非公平锁来说就不一样,所以子类在实现时需要按照场景各自实现这个方法。 AQS的同步队列,是一个双向链表,AQS则持有链表的头尾节点。对于尾节点的设置,是存在多线程竞争的,所以采用CAS的方式进行修改。对于头节点设置,则一定是拿到了同步状态的线程才能处理,所以修改头节点不需要采用CAS的方式。 AQS的同步状态,是一个int类型的整数,它在表示状态的同时还能表示数量。通常情况下,状态为0时表示无锁,状态大于0时表示锁的重入次数。另外,在读写锁的场景中,这个状态标志既要记录读锁又要记录写锁。于是,锁的实现者就将状态表示拆成高低两部分,高位存读锁、低位存写锁。 加分回答 同步状态需要在并发环境下修改,所以需要保证其线程安全。由于AQS本身就是锁的实现工具,所以不适合用锁来保证其线程安全,因为如果你用一个锁来定义另一个锁的话,那干脆直接用synchronized算了。实际上,同步状态是被volatile修饰的,该关键字可以保证状态变量的内存可见性,从而解决了线程安全问题。 加分回答 同步状态需要在并发环境下修改,所以需要保证其线程安全。由于AQS本身就是锁的实现工具,所以不适合用锁来保证其线程安全,因为如果你用一个锁来定义另一个锁的话,那干脆直接用synchronized算了。实际上,同步状态是被volatile修饰的,该关键字可以保证状态变量的内存可见性,从而解决了线程安全问题。</li></ol><h3 id="Java哪些地方使用了CAS"><a href="#Java哪些地方使用了CAS" class="headerlink" title="Java哪些地方使用了CAS"></a>Java哪些地方使用了CAS</h3><p>解题思路</p><p>得分点 原子类、AQS、并发容器 </p><p><strong>标准回答</strong> </p><p>Java提供的API中使用CAS的地方有很多,比较典型的使用场景有原子类、AQS、并发容器。 对于原子类,以AtomicInteger为例,它的内部提供了诸多原子操作的方法。如原子替换整数值、增加指定的值、加1,这些方法的底层便是采用操作系统提供的CAS原子指令来实现的。 </p><p>对于AQS,在向同步队列的尾部追加节点时,它首先会以CAS的方式尝试一次,如果失败则进入自旋状态,并反复以CAS的方式进行尝试。此外,在以共享方式释放同步状态时,它也是以CAS方式对同步状态进行修改的。 对于并发容器,以ConcurrentHashMap为例,它的内部多次使用了CAS操作。在初始化数组时,它会以CAS的方式修改初始化状态,避免多个线程同时进行初始化。在执行put方法初始化头节点时,它会以CAS的方式将初始化好的头节点设置到指定槽的首位,避免多个线程同时设置头节点。在数组扩容时,每个线程会以CAS方式修改任务序列号来争抢扩容任务,避免和其他线程产生冲突。在执行get方法时,它会以CAS的方式获取头指定槽的头节点,避免其他线程同时对头节点做出修改。 </p><p>加分回答 </p><p>CAS的实现离不开操作系统原子指令的支持,Java中对原子指令封装的方法集中在Unsafe类中,</p><p>包括：原子替换引用类型、原子替换int型整数、原子替换long型整数。</p><p>这些方法都有四个参数：var1、var2、var4、var5,</p><p>其中var1代表要操作的对象,</p><p>var2代表要替换的成员变量,</p><p>var4代表期望的值,</p><p>var5代表更新的值。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">( Object var1, <span class="type">long</span> var2, Object var4, Object var5)</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">( Object var1, <span class="type">long</span> var2, <span class="type">int</span> var4, <span class="type">int</span> var5)</span>; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">( Object var1, <span class="type">long</span> var2, <span class="type">long</span> var4, <span class="type">long</span> var6)</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2023/01/27/%E5%8F%8D%E5%B0%84%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/%E5%8F%8D%E5%B0%84%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请说说你对反射的了解"><a href="#请说说你对反射的了解" class="headerlink" title="请说说你对反射的了解"></a>请说说你对反射的了解</h3><p>解题思路</p><p>得分点 反射概念,通过反射机制可以实现什么 </p><p><strong>标准回答</strong></p><p> Java程序中,许多对象在运行时都会有编译时异常和运行时异常两种,</p><p>例如多态情况下Car c &#x3D; new Audi(); 这行代码运行时会生成一个c变量,在编译时该变量的类型是Car,运行时该变量类型为Audi；</p><p>另外还有更极端的情况,例如程序在运行时接收到了外部传入的一个对象,这个对象的编译时类型是Object,但程序又需要调用这个对象运行时类型的方法,这种情况下,有两种解决方法：</p><p>第一种做法是假设在编译时和运行时都完全知道类型的具体信息,在这种情况下,可以先使用instanceof运算符进行判断,再利用强制类型转换将其转换成其运行时类型的变量。</p><p>第二种做法是编译时根本无法预知该对象和类可能属于哪些类,程序只依靠运行时信息来发现该对象和类的真实信息,这就必须使用反射。 </p><p>具体来说,通过反射机制,我们可以实现如下的操作： </p><ul><li>程序运行时,可以通过反射获得任意一个类的Class对象,并通过这个对象查看这个类的信息；</li><li>程序运行时,可以通过反射创建任意一个类的实例,并访问该实例的成员；</li><li>程序运行时,可以通过反射机制生成一个类的动态代理类或动态代理对象。</li></ul><p><strong>加分回答</strong></p><p> Java的反射机制在实际项目中应用广泛,常见的应用场景有： </p><ul><li>使用JDBC时,如果要创建数据库的连接,则需要先通过反射机制加载数据库的驱动程序；</li><li>多数框架都支持注解&#x2F;XML配置,从配置中解析出来的类是字符串,需要利用反射机制实例化；</li><li>面向切面编程（AOP）的实现方案,是在程序运行时创建目标对象的代理类,这必须由反射机制来实现。</li></ul><h3 id="说说类加载机制"><a href="#说说类加载机制" class="headerlink" title="说说类加载机制"></a>说说类加载机制</h3><p>解题思路</p><p>得分点<br>加载、验证、准备、解析、初始化</p><p><strong>标准回答</strong></p><p>一个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载、验证、准备、解析、初始化、使用、卸载七个阶段，其中验证、准备、解析三个部分统称为连接，而前五个阶段则是类加载的完整过程。</p><p><img src="https://uploadfiles.nowcoder.com/images/20220226/4107856_1645862388602/D7FE993370822EC9232F21F54879124E" alt="img"></p><ol><li>在加载阶段JVM需要在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口。</li><li>验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。</li><li>准备阶段是正式为类中定义变量（静态变量）分配到内存并设置类变量初始值的阶段，这些变量所使用的内存都应当在方法区中进行分配，但必须注意到方法区本身是一个逻辑上的区域。</li><li>解析阶段是Java虚拟机将常量池内的符号替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，直接引用是可以直接指向目标的指针、相对偏移量或者一个能间接定位到目标的句柄。</li><li>类的初始化阶段是类加载过程的最后一个步骤，直到初始化阶段，Java虚拟机才真正开始执行类中编写的Java程序代码，将主导权移交给应用程序。本质上，初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它是Javac编译器的自动生成物。</clinit></clinit></li></ol><p><strong>加分回答</strong><br>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”：</p><ol><li>使用new实例化对象、读写类的静态字段、调用类的静态方法时。</li><li>使用java.lang.reflect包的方法对类型进行反射调用时。</li><li>当初始化类时，若发现其父类还没有进行过初始化，则先初始化这个父类。</li><li>虚拟机启动时，需要指定一个要执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li><li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2023/01/27/JUC%E9%9D%A2%E8%AF%95/"/>
      <url>/2023/01/27/JUC%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请你说说线程和协程的区别-进程和线程"><a href="#请你说说线程和协程的区别-进程和线程" class="headerlink" title="请你说说线程和协程的区别(进程和线程)"></a>请你说说线程和协程的区别(进程和线程)</h3><p>得分点 地址空间、开销、并发性、内存 标准回答 进程和线程的主要差别在于它们是不同的操作系统资源管理方式。</p><ol><li>进程有独立的地址空间,线程有自己的<strong>堆栈和局部变量</strong>,但线程之间没有单独的地址空间；</li><li>进程和线程切换时,需要切换进程和线程的上下文,进程的上下文切换时间开销远远大于线程上下文切换时间,耗费资源较大,效率要差一些；</li><li><strong>进程的并发性较低</strong>,<strong>线程的并发性较高</strong>；</li><li>每个独立的进程有一个程序运行的入口、顺序执行序列和程序的出口,但是线程不能够独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制；</li><li>系统在运行的时候会为每个进程分配不同的内存空间；而对线程而言,除了 CPU 外,系统不会为线程分配内存（线程所使用的资源来自其所属进程的资源）,线程组之间只能共享资源；</li><li>一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</li></ol><blockquote><p>进程是操作系统中资源分配的基本单位，它有自己独立的内存空间和系统资源，因此进程间的切换需要更多的系统开销，所以说进程的并发性较低。线程是进程的子任务，它可以共享进程的资源，因此线程间的切换开销更小，并发性更高。</p></blockquote><h3 id="请你说说多线程"><a href="#请你说说多线程" class="headerlink" title="请你说说多线程"></a>请你说说多线程</h3><p>解题思路</p><p>得分点 线程和进程的关系、为什么使用多线程 标准回答 线程是操作系统调度的最小单元,它可以让一个进程并发地处理多个任务,也叫轻量级进程。所以,在一个进程里可以创建多个线程,这些线程都拥有各自的计数器、堆栈、局部变量,并且能够共享进程内的资源。由于共享资源,处理器便可以在这些线程之间快速切换,从而让使用者感觉这些线程在同时执行。 总的来说,操作系统可以同时执行多个任务,每个任务就是一个进程。进程可以同时执行多个任务,每个任务就是一个线程。一个程序运行之后至少有一个进程,而一个进程可以包含多个线程,但至少要包含一个线程。 使用多线程会给开发人员带来显著的好处,而使用多线程的原因主要有以下几点：</p><ol><li>更多的CPU核心 现代计算机处理器性能的提升方式,已经从追求更高的主频向追求更多的核心发展,所以处理器的核心数量会越来越多,充分地利用处理器的核心则会显著地提高程序的性能。而程序使用多线程技术,就可以将计算逻辑分配到多个处理器核心上,显著减少程序的处理时间,从而随着更多处理器核心的加入而变得更有效率。</li><li>更快的响应时间 我们经常要针对复杂的业务编写出复杂的代码,如果使用多线程技术,就可以将数据一致性不强的操作派发给其他线程处理（也可以是消息队列）,如上传图片、发送邮件、生成订单等。这样响应用户请求的线程就能够尽快地完成处理,大大地缩短了响应时间,从而提升了用户体验。 3. 更好的编程模型 Java为多线程编程提供了良好且一致的编程模型,使开发人员能够更加专注于问题的解决,开发者只需为此问题建立合适的业务模型,而无需绞尽脑汁地考虑如何实现多线程。一旦开发人员建立好了业务模型,稍作修改就可以将其方便地映射到Java提供的多线程编程模型上。</li></ol><h3 id="说说怎么保证线程安全"><a href="#说说怎么保证线程安全" class="headerlink" title="说说怎么保证线程安全"></a>说说怎么保证线程安全</h3><p>解题思路</p><p>得分点 原子类、volatile、锁 标准回答 Java保证线程安全的方式有很多,其中较为常用的有三种,按照资源占用情况由轻到重排列,这三种保证线程安全的方式分别是原子类、volatile、锁。 JDK从1.5开始提供了java.util.concurrent.atomic包,这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。在atomic包里一共提供了17个类,按功能可以归纳为4种类型的原子更新方式,分别是原子更新基本类型、原子更新引用类型、原子更新属性、原子更新数组。无论原子更新哪种类型,都要遵循“比较和替换”规则,即比较要更新的值是否等于期望值,如果是则更新,如果不是则失败。 volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”,从而可以保证单个变量读写时的线程安全。可见性问题是由处理器核心的缓存导致的,每个核心均有各自的缓存,而这些缓存均要与内存进行同步。volatile具有如下的内存语义：当写一个volatile变量时,该线程本地内存中的共享变量的值会被立刻刷新到主内存；当读一个volatile变量时,该线程本地内存会被置为无效,迫使线程直接从主内存中读取共享变量。 原子类和volatile只能保证单个共享变量的线程安全,锁则可以保证临界区内的多个共享变量的线程安全,Java中加锁的方式有两种,分别是synchronized关键字和Lock接口。synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让它支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。因此,JDK的开发团队在1.5新增了Lock接口,并通过Lock支持了上述的功能,即：支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。 加分回答 实现线程安全的方式有很多,除了上述三种方式之外,还有如下几种方式： 1. 无状态设计 线程安全问题是由多线程并发修改共享变量引起的,如果在并发环境中没有设计共享变量,则自然就不会出现线程安全问题了。这种代码实现可以称作“无状态实现”,所谓状态就是指共享变量。 2. 不可变设计 如果在并发环境中不得不设计共享变量,则应该优先考虑共享变量是否为只读的,如果是只读场景就可以将共享变量设计为不可变的,这样自然也不会出现线程安全问题了。具体来说,就是在变量前加final修饰符,使其不可被修改,如果变量是引用类型,则将其设计为不可变类型（参考String类）。 3. 并发工具 java.util.concurrent包提供了几个有用的并发工具类,一样可以保证线程安全： - Semaphore：就是信号量,可以控制同时访问特定资源的线程数量。 - CountDownLatch：允许一个或多个线程等待其他线程完成操作。 - CyclicBarrier：让一组线程到达一个屏障时被阻塞,直到最后一个线程到达屏障时,屏障才会打开,所有被屏障拦截的线程才会继续运行。 4. 本地存储 我们也可以考虑使用ThreadLocal存储变量,ThreadLocal可以很方便地为每一个线程单独存一份数据,也就是将需要并发访问的资源复制成多份。这样一来,就可以避免多线程访问共享变量了,它们访问的是自己独占的资源,它从根本上隔离了多个线程之间的数据共享。</p><h3 id="请你说说死锁定义及发生的条件"><a href="#请你说说死锁定义及发生的条件" class="headerlink" title="请你说说死锁定义及发生的条件"></a>请你说说死锁定义及发生的条件</h3><p>解题思路</p><p>得分点 争夺共享资源、相互等待、互斥条件、请求和保持条件、不剥夺条件、环路等待条件 标准回答 1. 死锁 两个或两个以上的进程在执行过程中,因争夺共享资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。这些永远在互相等待的进程称为死锁进程。 2. 产生死锁的必要条件 虽然进程在运行过程中,可能发生死锁,但死锁的发生也必须具备一定的条件,死锁的发生必须具备以下四个必要条件： - 互斥条件：指进程对所分配到的资源进行排它性使用,即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源,则请求者只能等待,直至占有资源的进程用毕释放； - 请求和保持条件：指进程已经保持至少一个资源,但又提出了新的资源请求,而该资源已被其它进程占有,此时请求进程阻塞,但又对自己已获得的其它资源保持不放； - 不剥夺条件：指进程已获得的资源,在未使用完之前,不能被剥夺,只能在使用完时由自己释放； - 环路等待条件：指在发生死锁时,必然存在一个进程——资源的环形链,即进程集合 {P0,P1,P2,···,Pn} 中的 P0 正在等待一个 P1 占用的资源；P1 正在等待 P2 占用的资源,……,Pn 正在等待已被 P0 占用的资源。</p><h3 id="请你说说进程间的通信方式"><a href="#请你说说进程间的通信方式" class="headerlink" title="请你说说进程间的通信方式"></a>请你说说进程间的通信方式</h3><p>解题思路</p><p>得分点 管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket 标准答案 进程间通信主要包括：管道、命名管道、信号、消息队列、共享内存、内存映射、信号量、Socket： </p><ol><li><strong>管道</strong> 管道也叫无名（匿名）管道,它是是 UNIX 系统 IPC（进程间通信）的最古老形式,所有的 UNIX 系统都支持这种通信机制。管道本质其实是内核中维护的一块内存缓冲区,Linux 系统中通过 pipe() 函数创建管道,会生成两个文件描述符,分别对应管道的读端和写端。无名管道只能用于具有亲缘关系的进程间的通信。 </li><li><strong>命名管道</strong> 匿名管道,由于没有名字,只能用于亲缘关系的进程间通信。为了克服这个缺点,提出了有名管道（FIFO）,也叫命名管道、FIFO文件。有名管道（FIFO）不同于匿名管道之处在于它提供了一个路径名与之关联,以 FIFO 的文件形式存在于文件系统中,并且其打开方式与打开一个普通文件是一样的,这样即使与 FIFO 的创建进程不存在亲缘关系的进程,只要可以访问该路径,就能够彼此通过 FIFO 相互通信,因此,通过 FIFO 不相关的进程也能交换数据。 </li><li><strong>信号</strong> 信号是 Linux 进程间通信的最古老的方式之一,是事件发生时对进程的通知机制,有时也称之为软件中断,它是在软件层次上对中断机制的一种模拟,是一种异步通信的方式。信号可以导致一个正在运行的进程被另一个正在运行的异步进程中断,转而处理某一个突发事件。</li><li><strong>消息队列</strong> 消息队列就是一个消息的链表,可以把消息看作一个记录,具有特定的格式以及特定的优先级,对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息,对消息队列有读权限的进程则可以从消息队列中读走消息,消息队列是随内核持续的。 </li><li><strong>共享内存</strong> 共享内存允许两个或者多个进程共享物理内存的同一块区域（通常被称为段）。由于一个共享内存段会称为一个进程用户空间的一部分,因此这种 IPC 机制无需内核介入。所有需要做的就是让一个进程将数据复制进共享内存中,并且这部分数据会对其他所有共享同一个段的进程可用。与管道等要求发送进程将数据从用户空间的缓冲区复制进内核内存和接收进程将数据从内核内存复制进用户空间的缓冲区的做法相比,这种 IPC 技术的速度更快。 </li><li><strong>内存映射</strong> 内存映射（Memory-mapped I&#x2F;O）是将磁盘文件的数据映射到内存,用户通过修改内存就能修改磁盘文件。 </li><li><strong>信号量</strong> 信号量主要用来解决进程和线程间并发执行时的同步问题,进程同步是并发进程为了完成共同任务采用某个条件来协调它们的活动。对信号量的操作分为 P 操作和 V 操作,P 操作是将信号量的值减 1,V 操作是将信号量的值加 1。当信号量的值小于等于 0 之后,再进行 P 操作时,当前进程或线程会被阻塞,直到另一个进程或线程执行了 V 操作将信号量的值增加到大于 0 之时。 </li><li><strong>Socket 套接字</strong>（Socket）,就是对网络中不同主机上的应用进程之间进行双向通信的端点的抽象。一个套接字就是网络上进程通信的一端,提供了应用层进程利用网络协议交换数据的机制。Socket 一般用于网络中不同主机上的进程之间的通信。</li></ol><h3 id="请你说说乐观锁和悲观锁"><a href="#请你说说乐观锁和悲观锁" class="headerlink" title="请你说说乐观锁和悲观锁"></a>请你说说乐观锁和悲观锁</h3><p>解题思路</p><p>得分点 乐观锁、悲观锁定义及使用场景 标准回答 </p><p>乐观锁：乐观锁总是假设最好的情况,每次去拿数据的时候都认为别人不会修改,所以不会上锁,但是在更新的时候会判断一下在此期间别人有没有去更新这个数据,可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型,这样可以提<strong>高吞吐量</strong>,像数据库提供的类似于write_condition机制,其实都是提供的乐观锁。 </p><p>悲观锁：悲观锁总是假设最坏的情况,每次去拿数据的时候都认为别人会修改,所以每次在拿数据的时候都会上锁,这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用,其它线程阻塞,用完后再把资源转让给其它线程）。</p><p>传统的关系型数据库里边就用到了很多这种锁机制,比如行锁,表锁等,读锁,写锁等,都是在做操作之前先上锁。 </p><p>加分回答 两种锁的使用场景 乐观锁： GIT,SVN,CVS等代码版本控制管理器,就是一个乐观锁使用很好的场景,例如：A、B程序员,同时从SVN服务器上下载了code.html文件,当A完成提交后,此时B再提交,那么会报版本冲突,此时需要B进行版本处理合并后,再提交到服务器。这其实就是乐观锁的实现全过程。如果此时使用的是悲观锁,那么意味者所有程序员都必须一个一个等待操作提交完,才能访问文件,这是难以接受的。 </p><p>悲观锁： 悲观锁的好处在于可以减少并发,但是当并发量非常大的时候,由于锁消耗资源、锁定时间过长等原因,很容易导致系统性能下降,资源消耗严重。因此一般我们可以在并发量不是很大,并且出现并发情况导致的异常用户和系统都很难以接受的情况下,会选择悲观锁进行。</p><h3 id="说说你了解的线程同步方式"><a href="#说说你了解的线程同步方式" class="headerlink" title="说说你了解的线程同步方式"></a>说说你了解的线程同步方式</h3><p>解题思路</p><p>得分点 synchronized、Lock </p><p><strong>标准回答</strong> </p><p>Java主要通过加锁的方式实现线程同步,而锁有两类,分别是synchronized和Lock。 </p><p>synchronized可以加在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同： </p><ol><li>加在普通方法上,则锁是当前的实例（this）。 </li><li>加在静态方法上,则锁是当前类的Class对象。 </li><li>加在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。</li></ol><p>不同的锁对象,意味着不同的锁粒度,所以我们不应该无脑地将它加在方法前了事,尽管通常这可以解决问题。而是应该根据要锁定的范围,准确的选择锁对象,从而准确地确定锁的粒度,降低锁带来的性能开销。 synchronized是比较早期的API,在设计之初没有考虑到超时机制、非阻塞形式,以及多个条件变量。若想通过升级的方式让synchronized支持这些相对复杂的功能,则需要大改它的语法结构,不利于兼容旧代码。</p><p>因此,JDK的开发团队在1.5引入了Lock接口,并通过Lock支持了上述的功能。</p><p>Lock支持的功能包括：</p><p>支持响应中断、支持超时机制、支持以非阻塞的方式获取锁、支持多个条件变量（阻塞队列）。 </p><p><strong>加分回答</strong> </p><p>synchronized采用“CAS+Mark Word”实现,为了性能的考虑,并通过锁升级机制降低锁的开销。在并发环境中,synchronized会随着多线程竞争的加剧,按照如下步骤逐步升级：无锁、偏向锁、轻量级锁、重量级锁。 </p><p>Lock则采用“CAS+volatile”实现,其实现的核心是AQS。AQS是线程同步器,是一个线程同步的基础框架,它基于模板方法模式。在具体的Lock实例中,锁的实现是通过继承AQS来实现的,并且可以根据锁的使用场景,派生出公平锁、不公平锁、读锁、写锁等具体的实现。</p><h3 id="说说synchronize的用法及原理"><a href="#说说synchronize的用法及原理" class="headerlink" title="说说synchronize的用法及原理"></a>说说synchronize的用法及原理</h3><p>解题思路</p><p>得分点 作用于三个位置、对象头、锁升级 </p><p><strong>标准回答</strong> </p><p>用法 synchronized可以作用在三个不同的位置,对应三种不同的使用方式,这三种方式的区别是锁对象不同。不同的锁对象,意味着不同的锁粒度,所以我们不应该无脑地将它加在方法前了事,尽管通常这可以解决问题。而是应该根据要锁定的范围,准确的选择锁对象,从而准确地确定锁的粒度,降低锁带来的性能开销。</p><ol><li>作用在静态方法上,则锁是当前类的Class对象。</li><li>作用在普通方法上,则锁是当前的实例（this）。</li><li>作用在代码块上,则需要在关键字后面的小括号里,显式指定一个对象作为锁对象。 原理 synchronized的底层是采用Java对象头来存储锁信息的,并且还支持锁升级。 Java对象头包含三部分,分别是Mark Word、Class Metadata Address、Array length。其中,Mark Word用来存储对象的hashCode及锁信息,Class Metadata Address用来存储对象类型的指针,而Array length则用来存储数组对象的长度。如果对象不是数组类型,则没有Array length信息。synchronized的锁信息包括锁的标志和锁的状态,这些信息都存放在对象头的Mark Word这一部分。 Java 6为了减少获取锁和释放锁带来的性能消耗,引入了偏向锁和轻量级锁。所以,在Java 6中,锁一共被分为4种状态,级别由低到高依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。随着线程竞争情况的升级,锁的状态会从无锁状态逐步升级到重量级锁状态。锁可以升级却不能降级,这种只能升不能降的策略,是为了提高效率。 synchronized的早期设计并不包含锁升级机制,所以性能较差,那个时候只有无锁和有锁之分。是为了提升性能才引入了偏向锁和轻量级锁,所以需要重点关注这两种状态的原理,以及它们的区别。 偏向锁,顾名思义就是锁偏向于某一个线程。当一个线程访问同步块并获取锁时,会在对象头和栈帧中的锁记录里存储锁偏向的线程ID,以后该线程再进入和退出同步块时就不需要做加锁和解锁操作了,只需要简单地测试一下Mark Word里是否存储着自己的线程ID即可。 轻量级锁,就是加锁时JVM先在当前线程栈帧中创建用于存储锁记录的空间,并将Mark Word复制到锁记录中,官方称之为Displaced Mark Word。然后线程尝试以CAS方式将Mark Word替换为指向锁记录的指针,如果成功则当前线程获得锁,如果失败则表示其他线程竞争锁,此时当前线程就会通过自旋来尝试获取锁。 加分回答 下面,我们再从实际场景出发,来具体说说锁升级的过程： </li><li>开始,没有任何线程访问同步块,此时同步块处于无锁状态。</li><li>然后,线程1首先访问同步块,它以CAS的方式修改Mark Word,尝试加偏向锁。由于此时没有竞争,所以偏向锁加锁成功,此时Mark Word里存储的是线程1的ID。</li><li>然后,线程2开始访问同步块,它以CAS的方式修改Mark Word,尝试加偏向锁。由于此时存在竞争,所以偏向锁加锁失败,于是线程2会发起撤销偏向锁的流程（清空线程1的ID）,于是同步块从偏向线程1的状态恢复到了可以公平竞争的状态。</li><li>然后,线程1和线程2共同竞争,它们同时以CAS方式修改Mark Word,尝试加轻量级锁。由于存在竞争,只有一个线程会成功,假设线程1成功了。但线程2不会轻易放弃,它认为线程1很快就能执行完毕,执行权很快会落到自己头上,于是线程2继续自旋加锁。</li><li>最后,如果线程1很快执行完,则线程2就会加轻量级锁成功,锁不会晋升到重量级状态。也可能是线程1执行时间较长,那么线程2自旋一定次数后就放弃自旋,并发起锁膨胀的流程。届时,锁被线程2修改为重量级锁,之后线程2进入阻塞状态。而线程1重复加锁或者解锁时,CAS操作都会失败,此时它就会释放锁并唤醒等待的线程。 总之,在锁升级的机制下,锁不会一步到位变为重量级锁,而是根据竞争的情况逐步升级的。当竞争小的时候,只需以较小的代价加锁,直到竞争加剧,才使用重量级锁,从而减小了加锁带来的开销。</li></ol><h3 id="说说你对ThreadLocal的理解"><a href="#说说你对ThreadLocal的理解" class="headerlink" title="说说你对ThreadLocal的理解"></a>说说你对ThreadLocal的理解</h3><p>解题思路</p><p>得分点 作用、实现机制 </p><p><strong>标准回答</strong> </p><p>ThreadLocal,即线程变量,它将需要并发访问的资源复制多份,让每个线程拥有一份资源。由于每个线程都拥有自己的资源副本,从而也就没有必要对该变量进行同步了。</p><p>ThreadLocal提供了线程安全的共享机制,在编写多线程代码时,可以把不安全的变量封装进ThreadLocal。 </p><p>在实现上,Thread类中声明了threadLocals变量,用于存放当前线程独占的资源。ThreadLocal类中定义了该变量的类型（ThreadLocalMap）,这是一个类似于Map的结构,用于存放键值对。</p><p>ThreadLocal类中还提供了set和get方法,</p><p>set方法会初始化ThreadLocalMap并将其绑定到Thread.threadLocals,从而将传入的值绑定到当前线程。在数据存储上,传入的值将作为键值对的value,而key则是ThreadLocal对象本身（this）。</p><p>get方法没有任何参数,它会以当前ThreadLocal对象（this）为key,从Thread.threadLocals中获取与当前线程绑定的数据。 </p><p><strong>加分回答</strong> </p><p>注意,ThreadLocal不能替代同步机制,两者面向的问题领域不同。</p><p>同步机制是为了同步多个线程对相同资源的并发访问,是多个线程之间进行通信的有效方式。</p><p>而ThreadLocal是为了隔离多个线程的数据共享,从根本上避免多个线程之间对共享资源（变量）的竞争,也就不需要对多个线程进行同步了。 一般情况下,如果多个线程之间需要共享资源,以达到线程之间的通信功能,就使用同步机制。如果仅仅需要隔离多个线程之间的共享冲突,则可以使用ThreadLocal。</p><h3 id="说说volatile的用法及原理"><a href="#说说volatile的用法及原理" class="headerlink" title="说说volatile的用法及原理"></a>说说volatile的用法及原理</h3><p>解题思路</p><p>得分点 特性、内存语义、实现机制 </p><p><strong>标准回答</strong> </p><p>volatile是轻量级的synchronized,它在多处理器开发中保证了共享变量的“可见性”。</p><p>可见性的意思是当一个线程修改一个共享变量时,另外一个线程能读到这个修改的值。</p><p>如果volatile使用恰当的话,它比synchronized的执行成本更低,因为它不会引起线程上下文的切换和调度。</p><p>简而言之,volatile变量具有以下特性：</p><ul><li>可见性：对一个volatile变量的读,总是能看到（任意线程）对这个volatile变量最后的写入。 </li><li>原子性：对单个volatile变量的读写具有原子性,对“volatile变量++”这种复合操作则不具有原子性。</li></ul><p>volatile通过影响线程的内存可见性来实现上述特性,它具备如下的内存语义。</p><p>其中,JMM是指Java内存模型,而本地内存只是JMM的一个抽象概念,它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</p><p>在本文中,大家可以将其简单理解为缓存。 </p><ul><li>写内存语义：当写一个volatile变量时,JMM会把该线程本地内存中的共享变量的值刷新到主内存中。</li><li>读内存语义：当读一个volatile变量时,JMM会把该线程本地内存置为无效,使其从主内存中读取共享变量。</li></ul><p>volatile的底层是采用内存屏障来实现的,就是在编译器生成字节码时,会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。内存屏障就是一段与平台相关的代码,Java中的内存屏障代码都在Unsafe类中定义,共包含三个方法：LoadFence()、storeFence()、fullFence()。 </p><p><strong>加分回答</strong> </p><p>从内存语义的角度来说,volatile的读&#x2F;写,与锁的获取&#x2F;释放具有相同的内存效果。即volatile读与锁的获取有相同的内存语义,volatile写与锁的释放有相同的内存语义。 volatile只能保证单个变量读写的原子性,而锁则可以保证对整个临界区的代码执行具有原子性。所以,在功能上锁比volatile更强大,在可伸缩性和性能上volatile更优优势。</p><h3 id="说说wt-和sleep-的区别"><a href="#说说wt-和sleep-的区别" class="headerlink" title="说说wt()和sleep()的区别"></a>说说wt()和sleep()的区别</h3><p>解题思路</p><p>得分点 所属的类型不同、对锁的依赖不同、返回的条件不同 </p><p><strong>标准回答</strong> </p><p>wt()和sleep()方法主要有如下三个区别： </p><ol><li>所属的类型不同 <ol><li>wt()是Object类的实例方法,调用该方法的线程将进入WTING状态。 </li><li>sleep()是Thread类的静态方法,调用该方法的线程将进入TIMED_WTING状态。</li></ol></li><li>对锁的依赖不同 <ol><li>wt()依赖于synchronized锁,它必须通过监视器进行调用,在调用后线程会释放锁。 </li><li>sleep()不依赖于任何锁,所以在调用后它也不会释放锁。</li></ol></li><li>返回的条件不同 <ol><li>调用wt()进入等待状态的线程,需要由notify()&#x2F;notifyAll()唤醒,从而返回。 </li><li>调用sleep()进入超时等待的线程,需要在超时时间到达后自动返回。</li></ol></li></ol><p><strong>加分回答</strong> </p><p>wt()方法也支持超时参数,线程调用带有超时参数的wt()会进入TIMED_WTING状态,在此状态下的线程可以通过notify()&#x2F;notifyAll()唤醒从而返回,若在达到超时时间后仍然未被唤醒则自动返回。 </p><p>如果采用Lock进行线程同步,则不存在同步监视器,此时需要使用Condition的方法实现等待。</p><p>Condition对象是通过Lock对象创建出来的,它的awt()方法会导致线程进入WTING状态,它的带超时参数的awt()方法会导致线程进入TIMED_WTING状态,当调用它的signal()&#x2F;signalAll()方法时,线程会被唤醒从而返回。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2022/12/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95/"/>
      <url>/2022/12/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A2%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h3 id="请你说说虚拟内存和物理内存的区别"><a href="#请你说说虚拟内存和物理内存的区别" class="headerlink" title="请你说说虚拟内存和物理内存的区别"></a>请你说说虚拟内存和物理内存的区别</h3><p>解题思路</p><p><strong>标准回答</strong></p><p>1.物理内存 以前,还没有虚拟内存概念的时候,程序寻址用的都是物理地址。程序能寻址的范围是有限的,这取决于 CPU 的地址线条数。比如在 32 位平台下,寻址的范围是 2^32 也就是 4G。并且这是固定的,如果没有虚拟内存,且每次开启一个进程都给 4G 物理内存,就可能会出现很多问题： </p><ol><li>因为物理内存是有限的,当有多个进程要执行的时候,都要给 4G 内存,很显然内存不够,这很快就分配完了,于是没有得到分配资源的进程就只能等待。当一个进程执行完了以后,再将等待的进程装入内存。这种频繁的装入内存的操作效率很低</li><li>由于指令都是直接访问物理内存的,那么任何进程都可以修改其他进程的数据,甚至会修改内核地址空间的数据,这是不安全的</li></ol><p>2.虚拟内存 由于物理内存有很多问题,所以出现了虚拟内存。虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间）,而实际上,它通常是被分隔成多个物理内存碎片,还有部分暂时存储在外部磁盘存储器上,在需要时进行数据交换。</p><h3 id="请你说说内存管理"><a href="#请你说说内存管理" class="headerlink" title="请你说说内存管理"></a>请你说说内存管理</h3><p>解题思路</p><p>得分点 段页式内存管理方式 </p><p>标准回答</p><p> Linux 操作系统是采用段页式内存管理方式： </p><p>页式存储管理能有效地提高内存利用率（解决内存碎片）,而分段存储管理能反映程序的逻辑结构并有利于段的共享。</p><p>将这两种存储管理方法结合起来,就形成了段页式存储管理方式。 </p><p>段页式存储管理方式即先将用户程序分成若干个段,再把每个段分成若干个页,并为每一个段赋予一个段名。</p><p>在段页式系统中,为了实现从逻辑地址到物理地址的转换,系统中需要同时配置段表和页表,利用段表和页表进行从用户地址空间到物理内存空间的映射。 </p><p>系统为每一个进程建立一张段表,每个分段有一张页表。</p><p>段表表项中至少包括段号、页表长度和页表始址,页表表项中至少包括页号和块号。在进行地址转换时,首先通过段表查到页表始址,然后通过页表找到页帧号,最终形成物理地址。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>照片</title>
      <link href="/Gallery/index.html"/>
      <url>/Gallery/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index-1.html"/>
      <url>/link/index-1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>about</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>link</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
